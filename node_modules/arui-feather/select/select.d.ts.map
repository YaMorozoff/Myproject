{"version":3,"sources":["select/select.tsx"],"names":[],"mappings":"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","file":"select.d.ts","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport createFragment from 'react-addons-create-fragment';\nimport React from 'react';\nimport { createCn } from 'bem-react-classname';\nimport { withTheme } from '../cn';\n\nimport { Button } from '../button/button';\nimport IconButton from '../icon-button/icon-button';\nimport IconArrowDown from '../icon/ui/arrow-down';\nimport IconArrowUp from '../icon/ui/arrow-up';\nimport Menu from '../menu/menu';\nimport Mq from '../mq/mq';\nimport ThemedPopup from '../popup/popup';\nimport PopupHeader from '../popup-header/popup-header';\nimport { ResizeSensor } from '../resize-sensor/resize-sensor';\n\nimport { HtmlElement } from '../lib/prop-types';\nimport keyboardCode from '../lib/keyboard-code';\nimport performance from '../performance';\nimport scrollTo from '../lib/scroll-to';\nimport { SCROLL_TO_CORRECTION, SCROLL_TO_NORMAL_DURATION } from '../vars';\n\nconst DEFAULT_TEXT_FALLBACK = 'Выберите:';\n\n/**\n * Элемент кнопки для выпадающего списка.\n */\nclass NotThemedSelectButton extends Button {\n    cn = createCn('select-button');\n}\n\nconst SelectButton = withTheme(NotThemedSelectButton);\n\ntype CheckedOption = {\n    /**\n     * Уникальное значение, которое будет отправлено на сервер, если вариант выбран\n     */\n    value: string;\n    /**\n     * Текст варианта\n     */\n    text: string;\n    /**\n     * Текст, который будет отображаться при выборе\n     */\n    checkedText: string;\n    /**\n     * Иконка варианта\n     */\n    icon: React.ReactType;\n}\n\ntype SelectDirectionsFieldType = 'top-left' | 'top-center' | 'top-right' | 'left-top' | 'left-center' | 'left-bottom' | 'right-top' | 'right-center' | 'right-bottom' | 'bottom-left' | 'bottom-center' | 'bottom-right';\n\nexport type SelectOptionsShapeType = {\n\n    /**\n     * Тип списка вариантов\n     */\n    type?: 'item' | 'group';\n\n    /**\n     * Уникальное значение, которое будет отправлено на сервер, если вариант выбран\n     */\n    value?: string | number;\n\n    /**\n     * Текст варианта\n     */\n    text?: React.ReactNode;\n\n    /**\n     * Текст варианта для нативного режима\n     */\n    nativeText?: string;\n\n    /**\n     * Отображение варианта\n     */\n    description?: React.ReactNode;\n\n    /**\n     * Текст, который будет отображаться при выборе\n     */\n    checkedText?: string;\n\n    /**\n     * Иконка варианта\n     */\n    icon?: React.ReactNode;\n\n    /**\n     * Список вариантов, только для type='group'\n     */\n    content?: any[];\n\n    /**\n     * Только для type='item': свойства для компонента [MenuItem](#!/MenuItem)\n     */\n    props?: object;\n};\n\nexport type SelectProps = {\n\n    /**\n     * Дополнительный класс\n     */\n    className?: string;\n\n    /**\n     * Тип выпадающего списка\n     */\n    mode?: 'check' | 'radio' | 'radio-check';\n\n    /**\n     * Размещение заголовка групп: обычное или в одну строку с первым элементом группы\n     */\n    groupView?: 'default' | 'line';\n\n    /**\n     * Тип поля (filled только на белом фоне в размере m)\n     */\n    view?: 'default' | 'filled';\n\n    /**\n     * Управление возможностью компонента занимать всю ширину родителя\n     */\n    width?: 'default' | 'available';\n\n    /**\n     * Направления, в которые может открываться попап компонента\n     */\n    directions?: SelectDirectionsFieldType[];\n\n    /**\n     * Управление возможностью редактирования значения\n     */\n    disabled?: boolean;\n\n    /**\n     * Управление видимостью выпадающего списка\n     */\n    opened?: boolean;\n\n    /**\n     * Ширинa выпадающего списка равна ширине кнопки\n     */\n    equalPopupWidth?: boolean;\n\n    /**\n     * Список выбранных значений\n     */\n    value?: Array<string | number>;\n\n    /**\n     * Список вариантов выбора\n     */\n    options?: SelectOptionsShapeType[];\n\n    /**\n     * Вставляет попап со списком только если элемент активен\n     */\n    renderPopupOnFocus?: boolean;\n\n    /**\n     * Размер компонента\n     */\n    size?: 's' | 'm' | 'l' | 'xl';\n\n    /**\n     * Уникальный идентификатор блока\n     */\n    id?: string;\n\n    /**\n     * Уникальное имя блока\n     */\n    name?: string;\n\n    /**\n     * Лейбл для поля\n     */\n    label?: React.ReactNode;\n\n    /**\n     * Подсказка в поле\n     */\n    placeholder?: string;\n\n    /**\n     * Подсказка в качестве неактивного первого варианта выбора для нативного мобильного контрола\n     */\n    nativeOptionPlaceholder?: string;\n\n    /**\n     * Подсказка под полем\n     */\n    hint?: React.ReactNode;\n\n    /**\n     * Отображение ошибки\n     */\n    error?: React.ReactNode;\n\n    /**\n     * Управление нативным режимом на мобильных устройствах\n     */\n    mobileMenuMode?: 'native' | 'popup';\n\n    /**\n     * Подсказка над меню в мобильном режиме\n     */\n    mobileTitle?: React.ReactNode;\n\n    /**\n     * Смещение в пикселях всплывающего окна относительно основного направления (только на десктопе)\n     */\n    popupMainOffset?: number;\n\n    /**\n     * Смещение в пикселях всплывающего окна относительно второстепенного направления (только на десктопе)\n     */\n    popupSecondaryOffset?: number;\n\n    /**\n     * Скрытие галочки в правой части кнопки\n     */\n    hideTick?: boolean;\n\n    /**\n     * Тема компонента\n     */\n    theme?: 'alfa-on-color' | 'alfa-on-white';\n\n    /**\n     * Обработчик фокуса на компоненте\n     */\n    onFocus?: (event?: React.FocusEvent<any>) => void;\n\n    /**\n     * Обработчик потери фокуса компонентом\n     */\n    onBlur?: (event?: React.FocusEvent<any>) => void;\n\n    /**\n     * Обработчик фокуса на кнопке\n     */\n    onButtonFocus?: (event?: React.FocusEvent<any>) => void;\n\n    /**\n     * Обработчик потери у кнопки\n     */\n    onButtonBlur?: (event?: React.FocusEvent<any>) => void;\n\n    /**\n     * Обработчик фокуса на меню\n     */\n    onMenuFocus?: (event?: React.FocusEvent<any>) => void;\n\n    /**\n     * Обработчик потери фокуса у меню\n     */\n    onMenuBlur?: (event?: React.FocusEvent<any>) => void;\n\n    /**\n     * Обработчик клика по кнопке компонента\n     */\n    onClick?: (event?: React.MouseEvent<any>) => void;\n\n    /**\n     * Обработчик клика вне компонента\n     */\n    onClickOutside?: (event?: React.MouseEvent<any>) => void;\n\n    /**\n     * Обработчик изменения значения\n     */\n    onChange?: (value?: any[], event?: React.ChangeEvent<any>) => void;\n\n    /**\n     * Обработчик нажатия на клавишу\n     */\n    onKeyDown?: (event?: React.KeyboardEvent<any>) => void;\n\n    /**\n     * Кастомный метод рендера содержимого кнопки, принимает на вход: массив элементов типа CheckedOption\n     */\n    renderButtonContent?: (checkedOptions: CheckedOption[]) => React.ReactNode;\n\n    /**\n     * Максимальная высота попапа\n     */\n    maxHeight?: number;\n\n    /**\n     * Идентификатор для систем автоматизированного тестирования\n     */\n    'data-test-id'?: string;\n};\n\ntype SelectState = {\n    hasGroup: boolean;\n    isMobile: boolean;\n    opened: boolean;\n    popupStyles: {\n        minWidth?: number;\n        maxWidth?: number;\n    };\n    value: Array<string | number>;\n    popupIsReady?: boolean;\n};\n\n/**\n * Компонент выпадающего списка.\n */\n@performance(true)\nexport class Select extends React.Component<SelectProps, SelectState> {\n    protected cn = createCn('select');\n\n    static defaultProps: Partial<SelectProps> = {\n        mode: 'check',\n        groupView: 'default',\n        disabled: false,\n        size: 'm',\n        directions: ['bottom-left', 'bottom-right', 'top-left', 'top-right'],\n        view: 'default',\n        width: 'default',\n        equalPopupWidth: false,\n        options: [],\n        mobileTitle: DEFAULT_TEXT_FALLBACK,\n        nativeOptionPlaceholder: DEFAULT_TEXT_FALLBACK,\n        mobileMenuMode: 'native',\n        renderPopupOnFocus: false,\n    };\n\n    static contextTypes: any = {\n        positioningContainerElement: HtmlElement,\n    };\n\n    state: SelectState = {\n        hasGroup: false,\n        isMobile: false,\n        opened: !!this.props.opened,\n        popupStyles: {},\n        value: this.props.value || [],\n    };\n\n    private root: HTMLDivElement;\n\n    private button;\n\n    // TODO [issues/1018] переписать тесты нужно, что бы private был\n    popup;\n\n    private menu;\n\n    private nativeSelect: HTMLSelectElement;\n\n    /**\n     * При открытом меню, нажатие на Esc устанавливает значение этой переменной в true\n     * Далее фокус переводится на кнопку. Далее вызывается обработчик handleMenuBlur.\n     * В обработчике закрываем попап, если ожидаем закрытия(this.awaitClosing) или фокус за пределами селекта.\n     * Это нужно, т.к. в случае в renderPopupOnFocus={true} меню исчезнет быстрее, чем сработает onMenuBlur\n     */\n    private awaitClosing = false;\n\n    // eslint-disable-next-line camelcase\n    UNSAFE_componentWillMount() {\n        this.setState({\n            hasGroup: this.props.options.some((option) => !!(option.type === 'group' && !!option.content)),\n        });\n    }\n\n    componentDidMount() {\n        if (this.isAutoSelectRequired()) {\n            this.selectFirstOption();\n        }\n\n        this.setPopupTarget();\n        this.updatePopupStyles();\n    }\n\n    // eslint-disable-next-line camelcase\n    UNSAFE_componentWillReceiveProps(nextProps) {\n        this.setPopupTarget();\n        this.updatePopupStyles();\n\n        if (this.state.opened && nextProps.disabled) {\n            this.toggleOpened();\n        }\n\n        this.setState({\n            hasGroup: this.props.options.some((option) => !!(option.type === 'group' && !!option.content)),\n        });\n    }\n\n    componentDidUpdate() {\n        if (this.state.opened) {\n            this.updatePopupStyles();\n        }\n    }\n\n    render() {\n        const value = this.getValue();\n\n        return (\n            <div\n                className={ this.cn({\n                    mode: this.props.mode,\n                    size: this.props.size,\n                    view: this.props.view,\n                    width: this.props.width,\n                    checked: value.length > 0,\n                    disabled: this.props.disabled,\n                    'has-label': !!this.props.label,\n                    'has-value': !!value.length,\n                    'has-placeholder': !!this.props.placeholder,\n                    invalid: !!this.props.error,\n                    opened: this.getOpened(),\n                    'no-tick': this.props.hideTick,\n                }) }\n                ref={ (root) => {\n                    this.root = root;\n                } }\n                data-test-id={ this.props['data-test-id'] }\n            >\n                <span className={ this.cn('inner') }>\n                    <input id={ this.props.id } name={ this.props.name } type=\"hidden\" value={ value as any /* TODO: разобраться что тут происходит */ } />\n                    { !!this.props.label && <span className={ this.cn('top') }>{ this.props.label }</span> }\n                    { this.renderButton() }\n\n                    <Mq query=\"--small-only\" touch={ true } onMatchChange={ this.handleMqMatchChange }>\n                        { this.props.mobileMenuMode === 'native' && this.renderNativeSelect() }\n                    </Mq>\n\n                    { (this.props.error || this.props.hint) && (\n                        // The <div /> wrapper is needed to fix Safari bug of \"jumping\" element with\n                        // `display: table-caption`. See: https://github.com/alfa-laboratory/arui-feather/pull/656\n                        <div className={ this.cn('sub-wrapper') }>\n                            <span className={ this.cn('sub') }>{ this.props.error || this.props.hint }</span>\n                        </div>\n                    ) }\n\n                    { (!this.state.isMobile || (this.state.isMobile && this.props.mobileMenuMode === 'popup'))\n                        && this.renderPopup() }\n                </span>\n            </div>\n        );\n    }\n\n    renderButton() {\n        let tickSize;\n        let ToggledIcon;\n        const opened = this.getOpened();\n\n        switch (opened) {\n        case true:\n            ToggledIcon = IconArrowUp;\n            break;\n        case false:\n            ToggledIcon = IconArrowDown;\n            break;\n        }\n\n        switch (this.props.size) {\n        case 's':\n        case 'm':\n            tickSize = this.props.view === 'filled' ? 'l' : 's';\n            break;\n        case 'l':\n            tickSize = 'm';\n            break;\n        case 'xl':\n            tickSize = 'l';\n            break;\n        }\n\n        return (\n            <SelectButton\n                ref={ (button) => {\n                    this.button = button;\n                } }\n                size={ this.props.size }\n                disabled={ this.props.disabled }\n                focused={ this.getOpened() }\n                onClick={ this.handleButtonClick }\n                onFocus={ this.handleButtonFocus }\n                onBlur={ this.handleButtonBlur }\n            >\n                { this.renderButtonContent() }\n                { !this.props.hideTick && (\n                    <IconButton className={ this.cn('tick') } key=\"addon-icon\" size={ this.props.size } tag=\"span\">\n                        <ToggledIcon size={ tickSize } />\n                    </IconButton>\n                ) }\n\n                { this.getOpened() && (\n                    <ResizeSensor key=\"addon-sensor\" onResize={ this.updatePopupStyles } />\n                ) }\n            </SelectButton>\n        );\n    }\n\n    renderNativeSelect() {\n        const isCheckMode = this.props.mode === 'check';\n        const hasEmptyOptGroup = isCheckMode || this.state.hasGroup;\n        const hasEmptyOption = !isCheckMode && !this.state.hasGroup;\n        let value: any = this.getValue();\n\n        if (!isCheckMode) {\n            value = value.length ? value[0] : '';\n        }\n\n        return (\n            <select\n                ref={ (nativeSelect) => {\n                    this.nativeSelect = nativeSelect;\n                } }\n                className={ this.cn('native-control') }\n                disabled={ this.props.disabled }\n                multiple={ isCheckMode && 'multiple' as any }\n                value={ value }\n                onChange={ this.handleNativeOptionCheck }\n                onClick={ this.handleNativeClick }\n                onFocus={ this.handleNativeFocus }\n                onBlur={ this.handleNativeBlur }\n            >\n                { /*\n                        Хак с пустым <optgroup> — для фикса странного поведения select с атрибутом multiple на iOS7+:\n                        1. If no option is selected, it selects the first option in the list.\n                        2. If one option is selected, it deselects that option.\n                        3. If multiple options are selected, it deselects the last option to be tapped.\n                        4. If an option previously selected is deselected, it reselects the option.\n                        https://discussions.apple.com/message/23745665\n                        https://discussions.apple.com/message/24694954\n                    */\n                    hasEmptyOptGroup && <optgroup disabled={ true } label={ this.props.nativeOptionPlaceholder } />\n                }\n                { hasEmptyOption && (\n                    <option disabled={ true } value=\"\">\n                        { this.props.nativeOptionPlaceholder }\n                    </option>\n                ) }\n                { this.renderNativeOptionsList(this.props.options) }\n            </select>\n        );\n    }\n\n    renderPopup() {\n        const optionsList = this.renderOptionsList(this.props.options);\n        const opened = this.getOpened();\n        const value = this.getValue();\n        const { popupIsReady } = this.state;\n        const popupIsVisible = this.props.renderPopupOnFocus ? opened && popupIsReady : opened;\n\n        if (!opened && this.props.renderPopupOnFocus) {\n            return null;\n        }\n\n        return (\n            <ThemedPopup\n                key=\"popup\"\n                ref={ this.setPopupRef }\n                for={ this.props.name }\n                className={ this.cn('popup') }\n                directions={ this.props.directions }\n                height=\"adaptive\"\n                padded={ false }\n                mainOffset={ this.props.popupMainOffset }\n                secondaryOffset={ this.props.popupSecondaryOffset }\n                size={ this.props.size }\n                target={ this.state.isMobile ? 'screen' : 'anchor' }\n                header={ this.state.isMobile && this.renderMobileHeader() }\n                visible={ popupIsVisible }\n                onClickOutside={ this.handleClickOutside }\n                minWidth={ this.state.popupStyles.minWidth }\n                maxWidth={ this.state.popupStyles.maxWidth }\n                maxHeight={ this.props.maxHeight }\n            >\n                <Menu\n                    ref={ this.setMenuRef }\n                    className={ this.cn('menu') }\n                    size={ this.props.size }\n                    disabled={ this.props.disabled }\n                    mode={ this.props.mode }\n                    groupView={ this.props.groupView }\n                    content={ optionsList }\n                    onItemCheck={ this.handleOptionCheck }\n                    checkedItems={ value }\n                    onFocus={ this.handleMenuFocus }\n                    onBlur={ this.handleMenuBlur }\n                    onHighlightItem={ this.handleMenuHighlightItem }\n                    onKeyDown={ this.handleMenuKeyDown }\n                />\n            </ThemedPopup>\n        );\n    }\n\n    renderOptionsList(options) {\n        return options.map((option) => {\n            if (option.type === 'group' && !!option.content) {\n                const content = this.renderOptionsList(option.content);\n\n                return {\n                    type: 'group',\n                    title: option.title,\n                    content,\n                };\n            }\n\n            const content = option.description || option.text;\n\n            return {\n                props: option.props,\n                value: option.value,\n                content: createFragment({ icon: option.icon, content }),\n            };\n        });\n    }\n\n    renderNativeOptionsList(options) {\n        let groupKey = 0;\n\n        return options.map((option) => {\n            if (option.type === 'group' && !!option.content) {\n                const content = this.renderNativeOptionsList(option.content);\n\n                groupKey += 1;\n\n                return (\n                    <optgroup key={ `group_${groupKey}` } label={ option.title }>\n                        { content }\n                    </optgroup>\n                );\n            }\n\n            return (\n                <option key={ option.value } value={ option.value }>\n                    { option.nativeText || option.text }\n                </option>\n            );\n        });\n    }\n\n    renderButtonContent() {\n        const checkedItems = this.getCheckedItems(this.props.options);\n\n        if (this.props.renderButtonContent) {\n            return this.props.renderButtonContent(checkedItems);\n        }\n\n        const checkedItemsText = checkedItems.map((item) => item.checkedText || item.text).join(', ');\n\n        if (checkedItemsText) {\n            return checkedItemsText;\n        }\n\n        // Если ничего не выбрано, то рендерим плейсхолдер\n        // Если плейсхолдера нет, то рендерим текст лейбла. Но отрендерится он прозрачным - это нужно для того, чтобы\n        // лейбл растягивал блок до нужной ширины, т. к. настоящий лейбл позиционируется абсолютно и не влияет на размер\n        // Если нет ни плейсхолдера, ни лейбла, то рендерим \"Выберите:\" для обратной совместимости\n        return (\n            <span className={ this.cn('placeholder') }>\n                { this.props.placeholder || this.props.label || DEFAULT_TEXT_FALLBACK }\n            </span>\n        );\n    }\n\n    renderMobileHeader() {\n        return (\n            <PopupHeader\n                className={ this.cn('mobile-header') }\n                size={ this.props.size }\n                title={ this.props.mobileTitle }\n                onCloserClick={ this.handlePopupCloserClick }\n            />\n        );\n    }\n\n    private handleButtonClick = (event) => {\n        if (!this.props.disabled) {\n            this.toggleOpened();\n        }\n\n        if (this.props.onClick) {\n            this.props.onClick(event);\n        }\n    };\n\n    // TODO: не используется и вроде не публичный!!!!\n    handleButtonKeyDown = (event) => {\n        if (!this.props.disabled) {\n            if (event.which === keyboardCode.ENTER || event.which === keyboardCode.SPACE) {\n                this.toggleOpened();\n            }\n        }\n\n        if (this.props.onKeyDown) {\n            this.props.onKeyDown(event);\n        }\n    };\n\n    private handleButtonFocus = (event) => {\n        if (this.props.onButtonFocus) {\n            this.props.onButtonFocus(this.getRevisedEvent(event));\n        }\n    };\n\n    private handleButtonBlur = (event) => {\n        if (this.props.onButtonBlur) {\n            this.props.onButtonBlur(this.getRevisedEvent(event));\n        }\n    };\n\n    private handleMenuFocus = (event) => {\n        // eslint-disable-next-line no-param-reassign\n        event.target.value = this.getValue();\n\n        if (this.props.onFocus) {\n            this.props.onFocus(event);\n        }\n\n        if (this.props.onMenuFocus) {\n            this.props.onMenuFocus(event);\n        }\n    };\n\n    private handleMenuBlur = (event) => {\n        // eslint-disable-next-line no-param-reassign\n        event.target.value = this.getValue();\n\n        if (this.awaitClosing || event.relatedTarget !== this.button.getNode()) {\n            this.awaitClosing = false;\n            this.setState({\n                opened: false,\n            });\n        }\n\n        if (this.props.onBlur) {\n            this.props.onBlur(event);\n        }\n\n        if (this.props.onMenuBlur) {\n            this.props.onMenuBlur(event);\n        }\n    };\n\n    private handleMenuHighlightItem = (highlightedItem) => {\n        if (!this.getOpened() && highlightedItem && this.popup) {\n            this.popup.getInnerNode().scrollTop = 0;\n            this.scrollToHighlightedItem(highlightedItem);\n        }\n    };\n\n    private handleOptionCheck = (value, event) => {\n        const opened = this.getOpened();\n\n        this.setState({ value, opened: this.props.mode === 'check' }, () => {\n            // Если у Select-а закрылось выпадающее меню,\n            // то возвращаем фокус на кнопку Select\n            // после выбора опции.\n            const newOpened = this.getOpened();\n\n            if (!newOpened && opened !== newOpened) {\n                this.button.focus();\n            }\n        });\n\n        if (this.props.onChange) {\n            this.props.onChange(value, event);\n        }\n    };\n\n    private handleNativeOptionCheck = (event) => {\n        function getFlattenedPropOptions(options) {\n            let result = [];\n\n            options.forEach((option) => {\n                if (option.type === 'group' && !!option.content) {\n                    const findInGroup = getFlattenedPropOptions(option.content);\n\n                    result = result.concat(findInGroup);\n                } else {\n                    result.push(option);\n                }\n            });\n\n            return result;\n        }\n\n        const hasEmptyOption = this.props.mode !== 'check' && !this.state.hasGroup;\n        const domOptions = Array.from(event.currentTarget.options).filter(\n            (option: any, index) => !(hasEmptyOption && option.disabled && index === 0),\n        );\n        const flattenedPropOptions = getFlattenedPropOptions(this.props.options);\n        const value = domOptions.reduce((result: any[], item: any, index) => {\n            if (item.selected) {\n                result.push(flattenedPropOptions[index].value);\n            }\n\n            return result;\n        }, []) as any;\n\n        if (this.props.mode === 'radio' || this.props.mode === 'radio-check') {\n            this.blur();\n        }\n\n        this.setState({ value });\n\n        if (this.props.onChange) {\n            this.props.onChange(value, event);\n        }\n    };\n\n    private handleClickOutside = () => {\n        this.setState({\n            opened: false,\n        });\n\n        if (this.props.onClickOutside) {\n            this.props.onClickOutside();\n        }\n    };\n\n    private handleMenuKeyDown = (event, highlightedItem) => {\n        const opened = this.getOpened();\n\n        switch (event.which) {\n        case keyboardCode.DOWN_ARROW:\n        case keyboardCode.UP_ARROW:\n            event.preventDefault();\n            this.scrollToHighlightedItem(highlightedItem);\n            break;\n        case keyboardCode.ENTER:\n        case keyboardCode.SPACE:\n            event.preventDefault();\n            this.setState({\n                opened: this.props.mode === 'check' ? true : !opened,\n            });\n            this.focusOnMenu();\n            break;\n        case keyboardCode.ESCAPE:\n            event.preventDefault();\n            this.awaitClosing = true;\n            this.button.focus();\n            break;\n        }\n\n        if (this.props.onKeyDown) {\n            this.props.onKeyDown(event);\n        }\n    };\n\n    private handleNativeFocus = (event) => {\n        if (!this.props.disabled) {\n            this.toggleOpened();\n        }\n\n        if (this.props.onFocus) {\n            this.props.onFocus(this.getRevisedEvent(event));\n        }\n    };\n\n    private handleNativeBlur = (event) => {\n        if (!this.props.disabled) {\n            this.toggleOpened();\n        }\n\n        if (this.props.onBlur) {\n            this.props.onBlur(this.getRevisedEvent(event));\n        }\n    };\n\n    private handleNativeClick = (event) => {\n        if (this.props.onClick) {\n            this.props.onClick(this.getRevisedEvent(event));\n        }\n    };\n\n    private handleMqMatchChange = (isMatched) => {\n        this.setState(\n            {\n                isMobile: isMatched,\n            },\n            () => {\n                this.setPopupTarget();\n                this.updatePopupStyles();\n            },\n        );\n    };\n\n    private handlePopupCloserClick = () => {\n        this.setState({\n            opened: false,\n        });\n    };\n\n    private setPopupRef = (ref) => {\n        this.popup = ref;\n\n        if (this.popup) {\n            this.popup.setTarget(this.button.getNode());\n        }\n\n        if (this.props.renderPopupOnFocus) {\n            const popupIsReady = !!this.popup;\n\n            this.setState({\n                popupIsReady,\n            });\n\n            if (popupIsReady) {\n                setTimeout(() => {\n                    this.focusOnMenu();\n                }, 0);\n            }\n        }\n    };\n\n    private setMenuRef = (menu) => {\n        this.menu = menu;\n    };\n\n    /**\n     * Возвращает корневой `HTMLElement` компонента.\n     */\n    public getNode() {\n        return this.root;\n    }\n\n    /**\n     * Устанавливает фокус на компонент.\n     */\n    public focus() {\n        if (this.nativeSelect) {\n            this.nativeSelect.focus();\n        } else {\n            this.button.focus();\n\n            this.setState(\n                {\n                    opened: true,\n                },\n                () => {\n                    this.focusOnMenu();\n                },\n            );\n        }\n    }\n\n    /**\n     * Убирает фокус с компонента.\n     */\n    // eslint-disable-next-line class-methods-use-this\n    public blur() {\n        if (document.activeElement instanceof HTMLElement) {\n            document.activeElement.blur();\n        }\n    }\n\n    /**\n     * Скроллит страницу до компонента.\n     */\n    public scrollTo() {\n        const elementRect = this.root.getBoundingClientRect();\n\n        scrollTo({\n            // eslint-disable-next-line no-mixed-operators\n            targetY: elementRect.top + window.pageYOffset - SCROLL_TO_CORRECTION,\n        });\n    }\n\n    public focusOnMenu() {\n        if (!this.menu) {\n            return;\n        }\n\n        if (this.state.isMobile && this.props.mobileMenuMode === 'popup') {\n            return;\n        }\n\n        const scrollContainer = this.getScrollContainer();\n\n        const posX = scrollContainer.scrollTop;\n        const posY = scrollContainer.scrollLeft;\n\n        this.menu.focus();\n        scrollContainer.scrollTop = posX;\n        scrollContainer.scrollLeft = posY;\n    }\n\n    /**\n     * @param {MenuItem} highlightedItem Выбранный в текущий момент пункт меню\n     */\n    private scrollToHighlightedItem(highlightedItem) {\n        const element = highlightedItem.getNode();\n        const container = this.popup.getInnerNode();\n        const correction = element.offsetHeight;\n\n        if (container) {\n            if (element.offsetTop + correction > container.scrollTop + container.offsetHeight) {\n                scrollTo({\n                    container,\n                    targetY: element.offsetTop,\n                    duration: SCROLL_TO_NORMAL_DURATION,\n                });\n            } else if (element.offsetTop < container.scrollTop) {\n                scrollTo({\n                    container,\n                    // eslint-disable-next-line no-mixed-operators\n                    targetY: element.offsetTop - container.offsetHeight + correction,\n                    duration: SCROLL_TO_NORMAL_DURATION,\n                });\n            }\n        }\n    }\n\n    private toggleOpened() {\n        const newOpenedState = !this.getOpened();\n\n        this.setState(\n            {\n                opened: newOpenedState,\n            },\n            () => {\n                if (newOpenedState) {\n                    this.focusOnMenu();\n                }\n            },\n        );\n    }\n\n    private updatePopupStyles = () => {\n        const buttonWidth = this.button.getNode().getBoundingClientRect().width;\n        const popupStyles: { minWidth; maxWidth?} = { minWidth: buttonWidth };\n\n        if (this.props.equalPopupWidth) {\n            popupStyles.maxWidth = buttonWidth;\n        }\n\n        this.setState({ popupStyles });\n    };\n\n    private setPopupTarget = () => {\n        if (this.popup) {\n            this.popup.setTarget(this.button.getNode());\n        }\n    };\n\n    private getCheckedItems(options) {\n        const value = this.getValue();\n        let result = [];\n\n        options.forEach((option) => {\n            if (option.type === 'group' && !!option.content) {\n                const findInGroup = this.getCheckedItems(option.content);\n\n                result = result.concat(findInGroup);\n            } else if (value.indexOf(option.value) !== -1) {\n                result.push(option);\n            }\n        });\n\n        return result;\n    }\n\n    private getOpened() {\n        return this.props.opened === undefined ? this.state.opened : this.props.opened;\n    }\n\n    private getRevisedEvent(event) {\n        return { ...event, target: { ...event.target, value: this.getValue() } };\n    }\n\n    private getValue() {\n        return this.props.value || this.state.value;\n    }\n\n    getScrollContainer(): HTMLElement {\n        return this.context.positioningContainerElement || document.body;\n    }\n\n    private isAutoSelectRequired() {\n        const { mode, options, renderPopupOnFocus } = this.props;\n\n        return renderPopupOnFocus && mode === 'radio' && options.length > 0 && !this.hasCheckedItems();\n    }\n\n    private hasCheckedItems() {\n        const { options } = this.props;\n        const checkedItems = this.getCheckedItems(options);\n\n        return checkedItems.length > 0;\n    }\n\n    private selectFirstOption() {\n        const firstOption = this.getFirstOption(this.props.options);\n\n        this.handleOptionCheck([firstOption.value], null);\n    }\n\n    private getFirstOption(options) {\n        const firstOption = options[0];\n\n        if (firstOption.type === 'group') {\n            return this.getFirstOption(firstOption.content);\n        }\n\n        return firstOption;\n    }\n}\n\nexport default withTheme<SelectProps, Select>(Select);\n"]}