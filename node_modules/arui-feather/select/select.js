"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_addons_create_fragment_1 = __importDefault(require("react-addons-create-fragment"));
var react_1 = __importDefault(require("react"));
var bem_react_classname_1 = require("bem-react-classname");
var cn_1 = require("../cn");
var button_1 = require("../button/button");
var icon_button_1 = __importDefault(require("../icon-button/icon-button"));
var arrow_down_1 = __importDefault(require("../icon/ui/arrow-down"));
var arrow_up_1 = __importDefault(require("../icon/ui/arrow-up"));
var menu_1 = __importDefault(require("../menu/menu"));
var mq_1 = __importDefault(require("../mq/mq"));
var popup_1 = __importDefault(require("../popup/popup"));
var popup_header_1 = __importDefault(require("../popup-header/popup-header"));
var resize_sensor_1 = require("../resize-sensor/resize-sensor");
var prop_types_1 = require("../lib/prop-types");
var keyboard_code_1 = __importDefault(require("../lib/keyboard-code"));
var performance_1 = __importDefault(require("../performance"));
var scroll_to_1 = __importDefault(require("../lib/scroll-to"));
var vars_1 = require("../vars");
var DEFAULT_TEXT_FALLBACK = 'Выберите:';
/**
 * Элемент кнопки для выпадающего списка.
 */
var NotThemedSelectButton = /** @class */ (function (_super) {
    __extends(NotThemedSelectButton, _super);
    function NotThemedSelectButton() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.cn = bem_react_classname_1.createCn('select-button');
        return _this;
    }
    return NotThemedSelectButton;
}(button_1.Button));
var SelectButton = cn_1.withTheme(NotThemedSelectButton);
/**
 * Компонент выпадающего списка.
 */
var Select = /** @class */ (function (_super) {
    __extends(Select, _super);
    function Select() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.cn = bem_react_classname_1.createCn('select');
        _this.state = {
            hasGroup: false,
            isMobile: false,
            opened: !!_this.props.opened,
            popupStyles: {},
            value: _this.props.value || [],
        };
        /**
         * При открытом меню, нажатие на Esc устанавливает значение этой переменной в true
         * Далее фокус переводится на кнопку. Далее вызывается обработчик handleMenuBlur.
         * В обработчике закрываем попап, если ожидаем закрытия(this.awaitClosing) или фокус за пределами селекта.
         * Это нужно, т.к. в случае в renderPopupOnFocus={true} меню исчезнет быстрее, чем сработает onMenuBlur
         */
        _this.awaitClosing = false;
        _this.handleButtonClick = function (event) {
            if (!_this.props.disabled) {
                _this.toggleOpened();
            }
            if (_this.props.onClick) {
                _this.props.onClick(event);
            }
        };
        // TODO: не используется и вроде не публичный!!!!
        _this.handleButtonKeyDown = function (event) {
            if (!_this.props.disabled) {
                if (event.which === keyboard_code_1.default.ENTER || event.which === keyboard_code_1.default.SPACE) {
                    _this.toggleOpened();
                }
            }
            if (_this.props.onKeyDown) {
                _this.props.onKeyDown(event);
            }
        };
        _this.handleButtonFocus = function (event) {
            if (_this.props.onButtonFocus) {
                _this.props.onButtonFocus(_this.getRevisedEvent(event));
            }
        };
        _this.handleButtonBlur = function (event) {
            if (_this.props.onButtonBlur) {
                _this.props.onButtonBlur(_this.getRevisedEvent(event));
            }
        };
        _this.handleMenuFocus = function (event) {
            // eslint-disable-next-line no-param-reassign
            event.target.value = _this.getValue();
            if (_this.props.onFocus) {
                _this.props.onFocus(event);
            }
            if (_this.props.onMenuFocus) {
                _this.props.onMenuFocus(event);
            }
        };
        _this.handleMenuBlur = function (event) {
            // eslint-disable-next-line no-param-reassign
            event.target.value = _this.getValue();
            if (_this.awaitClosing || event.relatedTarget !== _this.button.getNode()) {
                _this.awaitClosing = false;
                _this.setState({
                    opened: false,
                });
            }
            if (_this.props.onBlur) {
                _this.props.onBlur(event);
            }
            if (_this.props.onMenuBlur) {
                _this.props.onMenuBlur(event);
            }
        };
        _this.handleMenuHighlightItem = function (highlightedItem) {
            if (!_this.getOpened() && highlightedItem && _this.popup) {
                _this.popup.getInnerNode().scrollTop = 0;
                _this.scrollToHighlightedItem(highlightedItem);
            }
        };
        _this.handleOptionCheck = function (value, event) {
            var opened = _this.getOpened();
            _this.setState({ value: value, opened: _this.props.mode === 'check' }, function () {
                // Если у Select-а закрылось выпадающее меню,
                // то возвращаем фокус на кнопку Select
                // после выбора опции.
                var newOpened = _this.getOpened();
                if (!newOpened && opened !== newOpened) {
                    _this.button.focus();
                }
            });
            if (_this.props.onChange) {
                _this.props.onChange(value, event);
            }
        };
        _this.handleNativeOptionCheck = function (event) {
            function getFlattenedPropOptions(options) {
                var result = [];
                options.forEach(function (option) {
                    if (option.type === 'group' && !!option.content) {
                        var findInGroup = getFlattenedPropOptions(option.content);
                        result = result.concat(findInGroup);
                    }
                    else {
                        result.push(option);
                    }
                });
                return result;
            }
            var hasEmptyOption = _this.props.mode !== 'check' && !_this.state.hasGroup;
            var domOptions = Array.from(event.currentTarget.options).filter(function (option, index) { return !(hasEmptyOption && option.disabled && index === 0); });
            var flattenedPropOptions = getFlattenedPropOptions(_this.props.options);
            var value = domOptions.reduce(function (result, item, index) {
                if (item.selected) {
                    result.push(flattenedPropOptions[index].value);
                }
                return result;
            }, []);
            if (_this.props.mode === 'radio' || _this.props.mode === 'radio-check') {
                _this.blur();
            }
            _this.setState({ value: value });
            if (_this.props.onChange) {
                _this.props.onChange(value, event);
            }
        };
        _this.handleClickOutside = function () {
            _this.setState({
                opened: false,
            });
            if (_this.props.onClickOutside) {
                _this.props.onClickOutside();
            }
        };
        _this.handleMenuKeyDown = function (event, highlightedItem) {
            var opened = _this.getOpened();
            switch (event.which) {
                case keyboard_code_1.default.DOWN_ARROW:
                case keyboard_code_1.default.UP_ARROW:
                    event.preventDefault();
                    _this.scrollToHighlightedItem(highlightedItem);
                    break;
                case keyboard_code_1.default.ENTER:
                case keyboard_code_1.default.SPACE:
                    event.preventDefault();
                    _this.setState({
                        opened: _this.props.mode === 'check' ? true : !opened,
                    });
                    _this.focusOnMenu();
                    break;
                case keyboard_code_1.default.ESCAPE:
                    event.preventDefault();
                    _this.awaitClosing = true;
                    _this.button.focus();
                    break;
            }
            if (_this.props.onKeyDown) {
                _this.props.onKeyDown(event);
            }
        };
        _this.handleNativeFocus = function (event) {
            if (!_this.props.disabled) {
                _this.toggleOpened();
            }
            if (_this.props.onFocus) {
                _this.props.onFocus(_this.getRevisedEvent(event));
            }
        };
        _this.handleNativeBlur = function (event) {
            if (!_this.props.disabled) {
                _this.toggleOpened();
            }
            if (_this.props.onBlur) {
                _this.props.onBlur(_this.getRevisedEvent(event));
            }
        };
        _this.handleNativeClick = function (event) {
            if (_this.props.onClick) {
                _this.props.onClick(_this.getRevisedEvent(event));
            }
        };
        _this.handleMqMatchChange = function (isMatched) {
            _this.setState({
                isMobile: isMatched,
            }, function () {
                _this.setPopupTarget();
                _this.updatePopupStyles();
            });
        };
        _this.handlePopupCloserClick = function () {
            _this.setState({
                opened: false,
            });
        };
        _this.setPopupRef = function (ref) {
            _this.popup = ref;
            if (_this.popup) {
                _this.popup.setTarget(_this.button.getNode());
            }
            if (_this.props.renderPopupOnFocus) {
                var popupIsReady = !!_this.popup;
                _this.setState({
                    popupIsReady: popupIsReady,
                });
                if (popupIsReady) {
                    setTimeout(function () {
                        _this.focusOnMenu();
                    }, 0);
                }
            }
        };
        _this.setMenuRef = function (menu) {
            _this.menu = menu;
        };
        _this.updatePopupStyles = function () {
            var buttonWidth = _this.button.getNode().getBoundingClientRect().width;
            var popupStyles = { minWidth: buttonWidth };
            if (_this.props.equalPopupWidth) {
                popupStyles.maxWidth = buttonWidth;
            }
            _this.setState({ popupStyles: popupStyles });
        };
        _this.setPopupTarget = function () {
            if (_this.popup) {
                _this.popup.setTarget(_this.button.getNode());
            }
        };
        return _this;
    }
    // eslint-disable-next-line camelcase
    Select.prototype.UNSAFE_componentWillMount = function () {
        this.setState({
            hasGroup: this.props.options.some(function (option) { return !!(option.type === 'group' && !!option.content); }),
        });
    };
    Select.prototype.componentDidMount = function () {
        if (this.isAutoSelectRequired()) {
            this.selectFirstOption();
        }
        this.setPopupTarget();
        this.updatePopupStyles();
    };
    // eslint-disable-next-line camelcase
    Select.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {
        this.setPopupTarget();
        this.updatePopupStyles();
        if (this.state.opened && nextProps.disabled) {
            this.toggleOpened();
        }
        this.setState({
            hasGroup: this.props.options.some(function (option) { return !!(option.type === 'group' && !!option.content); }),
        });
    };
    Select.prototype.componentDidUpdate = function () {
        if (this.state.opened) {
            this.updatePopupStyles();
        }
    };
    Select.prototype.render = function () {
        var _this = this;
        var value = this.getValue();
        return (react_1.default.createElement("div", { className: this.cn({
                mode: this.props.mode,
                size: this.props.size,
                view: this.props.view,
                width: this.props.width,
                checked: value.length > 0,
                disabled: this.props.disabled,
                'has-label': !!this.props.label,
                'has-value': !!value.length,
                'has-placeholder': !!this.props.placeholder,
                invalid: !!this.props.error,
                opened: this.getOpened(),
                'no-tick': this.props.hideTick,
            }), ref: function (root) {
                _this.root = root;
            }, "data-test-id": this.props['data-test-id'] },
            react_1.default.createElement("span", { className: this.cn('inner') },
                react_1.default.createElement("input", { id: this.props.id, name: this.props.name, type: "hidden", value: value /* TODO: разобраться что тут происходит */ }),
                !!this.props.label && react_1.default.createElement("span", { className: this.cn('top') }, this.props.label),
                this.renderButton(),
                react_1.default.createElement(mq_1.default, { query: "--small-only", touch: true, onMatchChange: this.handleMqMatchChange }, this.props.mobileMenuMode === 'native' && this.renderNativeSelect()),
                (this.props.error || this.props.hint) && (
                // The <div /> wrapper is needed to fix Safari bug of "jumping" element with
                // `display: table-caption`. See: https://github.com/alfa-laboratory/arui-feather/pull/656
                react_1.default.createElement("div", { className: this.cn('sub-wrapper') },
                    react_1.default.createElement("span", { className: this.cn('sub') }, this.props.error || this.props.hint))),
                (!this.state.isMobile || (this.state.isMobile && this.props.mobileMenuMode === 'popup'))
                    && this.renderPopup())));
    };
    Select.prototype.renderButton = function () {
        var _this = this;
        var tickSize;
        var ToggledIcon;
        var opened = this.getOpened();
        switch (opened) {
            case true:
                ToggledIcon = arrow_up_1.default;
                break;
            case false:
                ToggledIcon = arrow_down_1.default;
                break;
        }
        switch (this.props.size) {
            case 's':
            case 'm':
                tickSize = this.props.view === 'filled' ? 'l' : 's';
                break;
            case 'l':
                tickSize = 'm';
                break;
            case 'xl':
                tickSize = 'l';
                break;
        }
        return (react_1.default.createElement(SelectButton, { ref: function (button) {
                _this.button = button;
            }, size: this.props.size, disabled: this.props.disabled, focused: this.getOpened(), onClick: this.handleButtonClick, onFocus: this.handleButtonFocus, onBlur: this.handleButtonBlur },
            this.renderButtonContent(),
            !this.props.hideTick && (react_1.default.createElement(icon_button_1.default, { className: this.cn('tick'), key: "addon-icon", size: this.props.size, tag: "span" },
                react_1.default.createElement(ToggledIcon, { size: tickSize }))),
            this.getOpened() && (react_1.default.createElement(resize_sensor_1.ResizeSensor, { key: "addon-sensor", onResize: this.updatePopupStyles }))));
    };
    Select.prototype.renderNativeSelect = function () {
        var _this = this;
        var isCheckMode = this.props.mode === 'check';
        var hasEmptyOptGroup = isCheckMode || this.state.hasGroup;
        var hasEmptyOption = !isCheckMode && !this.state.hasGroup;
        var value = this.getValue();
        if (!isCheckMode) {
            value = value.length ? value[0] : '';
        }
        return (react_1.default.createElement("select", { ref: function (nativeSelect) {
                _this.nativeSelect = nativeSelect;
            }, className: this.cn('native-control'), disabled: this.props.disabled, multiple: isCheckMode && 'multiple', value: value, onChange: this.handleNativeOptionCheck, onClick: this.handleNativeClick, onFocus: this.handleNativeFocus, onBlur: this.handleNativeBlur },
            hasEmptyOptGroup && react_1.default.createElement("optgroup", { disabled: true, label: this.props.nativeOptionPlaceholder }),
            hasEmptyOption && (react_1.default.createElement("option", { disabled: true, value: "" }, this.props.nativeOptionPlaceholder)),
            this.renderNativeOptionsList(this.props.options)));
    };
    Select.prototype.renderPopup = function () {
        var optionsList = this.renderOptionsList(this.props.options);
        var opened = this.getOpened();
        var value = this.getValue();
        var popupIsReady = this.state.popupIsReady;
        var popupIsVisible = this.props.renderPopupOnFocus ? opened && popupIsReady : opened;
        if (!opened && this.props.renderPopupOnFocus) {
            return null;
        }
        return (react_1.default.createElement(popup_1.default, { key: "popup", ref: this.setPopupRef, for: this.props.name, className: this.cn('popup'), directions: this.props.directions, height: "adaptive", padded: false, mainOffset: this.props.popupMainOffset, secondaryOffset: this.props.popupSecondaryOffset, size: this.props.size, target: this.state.isMobile ? 'screen' : 'anchor', header: this.state.isMobile && this.renderMobileHeader(), visible: popupIsVisible, onClickOutside: this.handleClickOutside, minWidth: this.state.popupStyles.minWidth, maxWidth: this.state.popupStyles.maxWidth, maxHeight: this.props.maxHeight },
            react_1.default.createElement(menu_1.default, { ref: this.setMenuRef, className: this.cn('menu'), size: this.props.size, disabled: this.props.disabled, mode: this.props.mode, groupView: this.props.groupView, content: optionsList, onItemCheck: this.handleOptionCheck, checkedItems: value, onFocus: this.handleMenuFocus, onBlur: this.handleMenuBlur, onHighlightItem: this.handleMenuHighlightItem, onKeyDown: this.handleMenuKeyDown })));
    };
    Select.prototype.renderOptionsList = function (options) {
        var _this = this;
        return options.map(function (option) {
            if (option.type === 'group' && !!option.content) {
                var content_1 = _this.renderOptionsList(option.content);
                return {
                    type: 'group',
                    title: option.title,
                    content: content_1,
                };
            }
            var content = option.description || option.text;
            return {
                props: option.props,
                value: option.value,
                content: react_addons_create_fragment_1.default({ icon: option.icon, content: content }),
            };
        });
    };
    Select.prototype.renderNativeOptionsList = function (options) {
        var _this = this;
        var groupKey = 0;
        return options.map(function (option) {
            if (option.type === 'group' && !!option.content) {
                var content = _this.renderNativeOptionsList(option.content);
                groupKey += 1;
                return (react_1.default.createElement("optgroup", { key: "group_" + groupKey, label: option.title }, content));
            }
            return (react_1.default.createElement("option", { key: option.value, value: option.value }, option.nativeText || option.text));
        });
    };
    Select.prototype.renderButtonContent = function () {
        var checkedItems = this.getCheckedItems(this.props.options);
        if (this.props.renderButtonContent) {
            return this.props.renderButtonContent(checkedItems);
        }
        var checkedItemsText = checkedItems.map(function (item) { return item.checkedText || item.text; }).join(', ');
        if (checkedItemsText) {
            return checkedItemsText;
        }
        // Если ничего не выбрано, то рендерим плейсхолдер
        // Если плейсхолдера нет, то рендерим текст лейбла. Но отрендерится он прозрачным - это нужно для того, чтобы
        // лейбл растягивал блок до нужной ширины, т. к. настоящий лейбл позиционируется абсолютно и не влияет на размер
        // Если нет ни плейсхолдера, ни лейбла, то рендерим "Выберите:" для обратной совместимости
        return (react_1.default.createElement("span", { className: this.cn('placeholder') }, this.props.placeholder || this.props.label || DEFAULT_TEXT_FALLBACK));
    };
    Select.prototype.renderMobileHeader = function () {
        return (react_1.default.createElement(popup_header_1.default, { className: this.cn('mobile-header'), size: this.props.size, title: this.props.mobileTitle, onCloserClick: this.handlePopupCloserClick }));
    };
    /**
     * Возвращает корневой `HTMLElement` компонента.
     */
    Select.prototype.getNode = function () {
        return this.root;
    };
    /**
     * Устанавливает фокус на компонент.
     */
    Select.prototype.focus = function () {
        var _this = this;
        if (this.nativeSelect) {
            this.nativeSelect.focus();
        }
        else {
            this.button.focus();
            this.setState({
                opened: true,
            }, function () {
                _this.focusOnMenu();
            });
        }
    };
    /**
     * Убирает фокус с компонента.
     */
    // eslint-disable-next-line class-methods-use-this
    Select.prototype.blur = function () {
        if (document.activeElement instanceof HTMLElement) {
            document.activeElement.blur();
        }
    };
    /**
     * Скроллит страницу до компонента.
     */
    Select.prototype.scrollTo = function () {
        var elementRect = this.root.getBoundingClientRect();
        scroll_to_1.default({
            // eslint-disable-next-line no-mixed-operators
            targetY: elementRect.top + window.pageYOffset - vars_1.SCROLL_TO_CORRECTION,
        });
    };
    Select.prototype.focusOnMenu = function () {
        if (!this.menu) {
            return;
        }
        if (this.state.isMobile && this.props.mobileMenuMode === 'popup') {
            return;
        }
        var scrollContainer = this.getScrollContainer();
        var posX = scrollContainer.scrollTop;
        var posY = scrollContainer.scrollLeft;
        this.menu.focus();
        scrollContainer.scrollTop = posX;
        scrollContainer.scrollLeft = posY;
    };
    /**
     * @param {MenuItem} highlightedItem Выбранный в текущий момент пункт меню
     */
    Select.prototype.scrollToHighlightedItem = function (highlightedItem) {
        var element = highlightedItem.getNode();
        var container = this.popup.getInnerNode();
        var correction = element.offsetHeight;
        if (container) {
            if (element.offsetTop + correction > container.scrollTop + container.offsetHeight) {
                scroll_to_1.default({
                    container: container,
                    targetY: element.offsetTop,
                    duration: vars_1.SCROLL_TO_NORMAL_DURATION,
                });
            }
            else if (element.offsetTop < container.scrollTop) {
                scroll_to_1.default({
                    container: container,
                    // eslint-disable-next-line no-mixed-operators
                    targetY: element.offsetTop - container.offsetHeight + correction,
                    duration: vars_1.SCROLL_TO_NORMAL_DURATION,
                });
            }
        }
    };
    Select.prototype.toggleOpened = function () {
        var _this = this;
        var newOpenedState = !this.getOpened();
        this.setState({
            opened: newOpenedState,
        }, function () {
            if (newOpenedState) {
                _this.focusOnMenu();
            }
        });
    };
    Select.prototype.getCheckedItems = function (options) {
        var _this = this;
        var value = this.getValue();
        var result = [];
        options.forEach(function (option) {
            if (option.type === 'group' && !!option.content) {
                var findInGroup = _this.getCheckedItems(option.content);
                result = result.concat(findInGroup);
            }
            else if (value.indexOf(option.value) !== -1) {
                result.push(option);
            }
        });
        return result;
    };
    Select.prototype.getOpened = function () {
        return this.props.opened === undefined ? this.state.opened : this.props.opened;
    };
    Select.prototype.getRevisedEvent = function (event) {
        return __assign(__assign({}, event), { target: __assign(__assign({}, event.target), { value: this.getValue() }) });
    };
    Select.prototype.getValue = function () {
        return this.props.value || this.state.value;
    };
    Select.prototype.getScrollContainer = function () {
        return this.context.positioningContainerElement || document.body;
    };
    Select.prototype.isAutoSelectRequired = function () {
        var _a = this.props, mode = _a.mode, options = _a.options, renderPopupOnFocus = _a.renderPopupOnFocus;
        return renderPopupOnFocus && mode === 'radio' && options.length > 0 && !this.hasCheckedItems();
    };
    Select.prototype.hasCheckedItems = function () {
        var options = this.props.options;
        var checkedItems = this.getCheckedItems(options);
        return checkedItems.length > 0;
    };
    Select.prototype.selectFirstOption = function () {
        var firstOption = this.getFirstOption(this.props.options);
        this.handleOptionCheck([firstOption.value], null);
    };
    Select.prototype.getFirstOption = function (options) {
        var firstOption = options[0];
        if (firstOption.type === 'group') {
            return this.getFirstOption(firstOption.content);
        }
        return firstOption;
    };
    Select.defaultProps = {
        mode: 'check',
        groupView: 'default',
        disabled: false,
        size: 'm',
        directions: ['bottom-left', 'bottom-right', 'top-left', 'top-right'],
        view: 'default',
        width: 'default',
        equalPopupWidth: false,
        options: [],
        mobileTitle: DEFAULT_TEXT_FALLBACK,
        nativeOptionPlaceholder: DEFAULT_TEXT_FALLBACK,
        mobileMenuMode: 'native',
        renderPopupOnFocus: false,
    };
    Select.contextTypes = {
        positioningContainerElement: prop_types_1.HtmlElement,
    };
    Select = __decorate([
        performance_1.default(true)
    ], Select);
    return Select;
}(react_1.default.Component));
exports.Select = Select;
exports.default = cn_1.withTheme(Select);

//# sourceMappingURL=select.js.map
