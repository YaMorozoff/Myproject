"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var inputmask_core_1 = __importDefault(require("inputmask-core"));
// Стандартный плейсхолдер буквы равный по ширине цифровому символу.
var PLACEHOLDER_CHAR = '\u2007';
// Стандартные formatCharacters из inputmask-core.
var DIGIT_RE = /^\d$/;
var LETTER_RE = /^[A-Za-z]$/;
var ALPHANNUMERIC_RE = /^[\dA-Za-z]$/;
var DEFAULT_FORMAT_CHARACTERS = {
    '*': {
        validate: function (char) {
            return ALPHANNUMERIC_RE.test(char);
        },
    },
    1: {
        validate: function (char) {
            return DIGIT_RE.test(char);
        },
    },
    a: {
        validate: function (char) {
            return LETTER_RE.test(char);
        },
    },
    A: {
        validate: function (char) {
            return LETTER_RE.test(char);
        },
        transform: function (char) {
            return char.toUpperCase();
        },
    },
    '#': {
        validate: function (char) {
            return ALPHANNUMERIC_RE.test(char);
        },
        transform: function (char) {
            return char.toUpperCase();
        },
    },
};
/**
 * Класс маски. Позволяет форматировать строку по заданной маске.
 */
var Mask = /** @class */ (function () {
    /**
     * @param mask Маска в формате: https://github.com/insin/inputmask-core
     * @param formatCharacters Форматтеры маски в формате `inputmask-core`
     */
    function Mask(mask, formatCharacters, useWhitespaces) {
        this.pattern = new inputmask_core_1.default.Pattern(mask, __assign(__assign({}, DEFAULT_FORMAT_CHARACTERS), formatCharacters), PLACEHOLDER_CHAR);
        this.length = this.pattern.length;
        this.firstEditableIndex = this.pattern.firstEditableIndex;
        this.lastEditableIndex = this.pattern.lastEditableIndex;
        this.useWhitespaces = useWhitespaces || false;
    }
    /**
     * Проверяет является ли символ в заданном индексе редактируемым.
     *
     * @param index Индекс символа.
     */
    Mask.prototype.isEditableIndex = function (index) {
        return this.pattern.isEditableIndex(index);
    };
    /**
     * Форматирует значение введенное в поле ввода по маске.
     *
     * @param value Неформатированное значение из поля ввода.
     */
    Mask.prototype.format = function (value) {
        var formattedValue = '';
        var cleanValue = this.useWhitespaces ? value : value.replace(/\s+/g, '');
        var cleanValueLength = cleanValue.length;
        var cleanValueIndex = 0;
        var cleanValueChar;
        var patternIndex = 0;
        var patternChar;
        var patternLength = this.pattern.length;
        while (patternIndex < patternLength && cleanValueIndex < cleanValueLength) {
            if (this.pattern.isEditableIndex(patternIndex)) {
                // eslint-disable-next-line no-cond-assign
                while ((cleanValueChar = cleanValue.charAt(cleanValueIndex)) !== '') {
                    if (this.pattern.isValidAtIndex(cleanValueChar, patternIndex)) {
                        formattedValue += this.pattern.transform(cleanValueChar, patternIndex);
                        patternIndex += 1;
                        cleanValueIndex += 1;
                        break;
                    }
                    else {
                        cleanValueIndex += 1;
                    }
                }
            }
            else {
                patternChar = this.pattern.pattern[patternIndex];
                formattedValue += patternChar;
                patternIndex += 1;
                if (cleanValue.charAt(cleanValueIndex) === patternChar) {
                    cleanValueIndex += 1;
                }
            }
        }
        return formattedValue;
    };
    return Mask;
}());
exports.default = Mask;

//# sourceMappingURL=mask.js.map
