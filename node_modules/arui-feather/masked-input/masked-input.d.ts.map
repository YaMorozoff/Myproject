{"version":3,"sources":["masked-input/masked-input.tsx"],"names":[],"mappings":"AAIA,OAAO,KAAK,MAAM,OAAO,CAAC;AAE1B,OAAa,EAAE,gBAAgB,EAAE,MAAM,QAAQ,CAAC;AAOhD;;GAEG;AACH,wBAAgB,iBAAiB,IAAI,MAAM,GAAG,KAAK,CASlD;AA2BD,oBAAY,gBAAgB,GAAG;IAC3B;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;OAEG;IACH,gBAAgB,CAAC,EAAE,gBAAgB,CAAC;IAEpC;;OAEG;IACH,SAAS,CAAC,EAAE,MAAM,CAAC;IAEnB;;OAEG;IACH,mBAAmB,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC;IAE/D;;OAEG;IACH,cAAc,CAAC,EAAE,OAAO,CAAC;IAEzB;;OAEG;IACH,cAAc,CAAC,EAAE,MAAM,CAAC;IAExB;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAC;IAEf;;OAEG;IACH,QAAQ,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC;IAEpD;;OAEG;IACH,OAAO,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC;IAEnD;;OAEG;IACH,aAAa,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC;CAC1D,CAAC;AAEF;;;GAGG;AACH,cAAM,WAAY,SAAQ,KAAK,CAAC,aAAa,CAAC,gBAAgB,CAAC;IAE3D,KAAK,EAAE,gBAAgB,CAAC;IAExB,OAAO,CAAC,WAAW,CAAS;IAE5B,OAAO,CAAC,IAAI,CAAO;IAEnB,OAAO,CAAC,gBAAgB,CAAO;IAE/B,OAAO,CAAC,gBAAgB,CAAmB;IAE3C,OAAO,CAAC,KAAK,CAAM;IAEnB,OAAO,CAAC,eAAe,CAAuC;IAE9D,OAAO,CAAC,oBAAoB,CAAwB;IAGpD,yBAAyB;IAOzB,gCAAgC,CAAC,SAAS,KAAA;IAe1C,oBAAoB;IAOpB,MAAM;IAsBN,OAAO,CAAC,iBAAiB,CASvB;IAEF;;;;OAIG;IACH,OAAO,CAAC,WAAW,CAYjB;IAEF;;;;OAIG;IACH,OAAO,CAAC,YAAY,CAUlB;IAEF;;OAEG;IACI,KAAK;IAIZ;;OAEG;IACI,IAAI;IAIX;;OAEG;IACI,UAAU;IAIjB;;;;;;OAMG;IACI,OAAO,CAAC,OAAO,EAAE,MAAM,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,cAAc,CAAC,EAAE,OAAO;IAS5F,OAAO,CAAC,iBAAiB;IAoGzB;;;;OAIG;IACH,OAAO,CAAC,cAAc;IAatB;;;;OAIG;IACH,OAAO,CAAC,iBAAiB;IAYzB;;;;;;;;OAQG;IACH,OAAO,CAAC,0BAA0B;CAYrC;AAED,eAAe,WAAW,CAAC","file":"masked-input.d.ts","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport React from 'react';\n\nimport Mask, { FormatCharacters } from './mask';\n\n// В эту проверку попадают IE9 и IE10, которые не могут корректно работать с кареткой на событии `input`.\nconst IS_IE9_10 = typeof window !== 'undefined' && !!(window as any).ActiveXObject;\n\nconst IS_ANDROID = typeof window !== 'undefined' && /(android)/i.test(window.navigator.userAgent);\n\n/**\n * Возвращает версию андроида в формате \"4.2.1\" или false, если не андроид.\n */\nexport function getAndroidVersion(): string | false {\n    if (!/android/.test(navigator.userAgent.toLowerCase())) {\n        return false;\n    }\n\n    const userAgent = navigator.userAgent.toLowerCase();\n    const match = userAgent.match(/android\\s([\\d.]*)/);\n\n    return match ? match[1] : false;\n}\n\n// Для IE11 вместо `onChange`, используем событие `onInput`, для правильной работы copy/paste\n// Issue на ошибку в React: https://github.com/facebook/react/issues/7211\n// Детектим IE11: `Object.hasOwnProperty.call(window, 'ActiveXObject') && !window.ActiveXObject;`\nconst IS_IE11 = typeof window !== 'undefined' && Object.hasOwnProperty.call(window, 'ActiveXObject') && !(window as any).ActiveXObject;\n\n// Типы операции, которые пользователь может производить с текстовым полем.\nconst operationType = {\n    ADD: 0,\n    DELETE: 1,\n    REPLACE: 2,\n};\n\n/**\n * Возвращает количество не редактируемых символов в строке, в соответствии с указанной маской.\n */\nconst getSeparatorsAmount = (str: string, mask: Mask): number => (\n    str.split('').reduce((amount, _char, index) => {\n        if (mask.isEditableIndex(index)) {\n            return amount;\n        }\n\n        return amount + 1;\n    }, 0)\n);\n\nexport type MaskedInputProps = {\n    /**\n     * Маска для поля ввода, использует формат https://github.com/insin/inputmask-core\n     */\n    mask: string;\n\n    /**\n     * Кастомные форматтеры символов маски, использует формат formatCharacters из `inputmask-core`\n     */\n    formatCharacters?: FormatCharacters;\n\n    /**\n     * Максимальное число символов\n     */\n    maxLength?: number;\n\n    /**\n     * Обработчик, вызываемый перед началом ввода в поле\n     */\n    onProcessInputEvent?: (event?: React.ChangeEvent<any>) => void;\n\n    /**\n     * Признак что пробелы удалять не надо\n     */\n    useWhitespaces?: boolean;\n\n    /**\n     * Идентификатор для систем автоматизированного тестирования\n     */\n    'data-test-id'?: string;\n\n    /**\n     * Содержимое поля ввода\n     */\n    value?: string;\n\n    /**\n     * Обработчик события, вызываемый при событии 'change'\n     */\n    onChange?: (event?: React.ChangeEvent<any>) => void;\n\n    /**\n     * Обработчик события, вызываемый при событии 'input'\n     */\n    onInput?: (event?: React.ChangeEvent<any>) => void;\n\n    /**\n     * Обработчик события, вызываемый при событии 'beforeInput'\n     */\n    onBeforeInput?: (event?: React.FormEvent<any>) => void;\n};\n\n/**\n * Компонент поля ввода с поддержкой масок.\n * Расширяет стандартный <input /> React-а.\n */\nclass MaskedInput extends React.PureComponent<MaskedInputProps> {\n    // TODO [issues/1018] на private ругается\n    input: HTMLInputElement;\n\n    private maskPattern: string;\n\n    private mask: Mask;\n\n    private beforeChangeMask: Mask;\n\n    private formatCharacters: FormatCharacters;\n\n    private value = '';\n\n    private caretFixTimeout: ReturnType<typeof setTimeout> = null;;\n\n    private beforeInputSelection = { start: 0, end: 0 };\n\n    // eslint-disable-next-line camelcase\n    UNSAFE_componentWillMount() {\n        this.setMask(this.props.mask, this.props.formatCharacters, this.props.useWhitespaces);\n        this.beforeChangeMask = this.mask;\n        this.value = this.mask.format(this.props.value || '');\n    }\n\n    // eslint-disable-next-line camelcase\n    UNSAFE_componentWillReceiveProps(nextProps) {\n        let reformatValue = false;\n\n        this.beforeChangeMask = this.mask;\n\n        if (this.props.mask !== nextProps.mask || this.props.formatCharacters !== nextProps.formatCharacters) {\n            this.setMask(nextProps.mask, nextProps.formatCharacters, nextProps.useWhitespaces);\n            reformatValue = true;\n        }\n\n        if (reformatValue || this.props.value !== nextProps.value) {\n            this.value = this.mask.format(nextProps.value || '');\n        }\n    }\n\n    componentWillUnmount() {\n        if (this.caretFixTimeout) {\n            clearTimeout(this.caretFixTimeout);\n            this.caretFixTimeout = null;\n        }\n    }\n\n    render() {\n        const props = { ...this.props };\n\n        delete props.mask;\n        delete props.formatCharacters;\n        delete props.onProcessInputEvent;\n        delete props.useWhitespaces;\n\n        return (\n            <input\n                { ...props }\n                ref={ (ref) => {\n                    this.input = ref;\n                } }\n                value={ this.value }\n                onBeforeInput={ this.handleBeforeInput }\n                onInput={ this.handleInput }\n                onChange={ this.handleChange }\n            />\n        );\n    }\n\n    private handleBeforeInput = (event) => {\n        this.beforeInputSelection = {\n            start: this.input.selectionStart,\n            end: this.input.selectionEnd,\n        };\n\n        if (this.props.onBeforeInput) {\n            this.props.onBeforeInput(event);\n        }\n    };\n\n    /**\n     * Обрабатывает событие «input».\n     *\n     * @param event The Event object\n     */\n    private handleInput = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const processedEvent = IS_IE9_10 ? event : this.processInputEvent(event);\n\n        if (this.props.onInput) {\n            this.props.onInput(processedEvent);\n        }\n\n        if (IS_IE11) {\n            if (this.props.onChange) {\n                this.props.onChange(processedEvent);\n            }\n        }\n    };\n\n    /**\n     * Обрабатывает событие «change».\n     *\n     * @param event The Event object\n     */\n    private handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        if (IS_IE11 || !this.props.onChange) {\n            return;\n        }\n\n        const processedInput = IS_IE9_10 ? this.processInputEvent(event) : event;\n\n        if (this.props.onChange) {\n            this.props.onChange(processedInput);\n        }\n    };\n\n    /**\n     * Устанавливает фокус на поле ввода.\n     */\n    public focus() {\n        this.input.focus();\n    }\n\n    /**\n     * Снимает фокус с поля ввода.\n     */\n    public blur() {\n        this.input.blur();\n    }\n\n    /**\n     * Возвращает ссылку на HTMLElement инпута.\n     */\n    public getControl() {\n        return this.input;\n    }\n\n    /**\n     * Синхронно обновляет маску на поле ввода.\n     *\n     * @param newMask Новая маска\n     * @param formatCharacters Форматтер маски\n     * @param useWhitespaces использовать в маске пробелы\n     */\n    public setMask(newMask: string, formatCharacters: FormatCharacters, useWhitespaces?: boolean) {\n        if (this.maskPattern !== newMask || this.formatCharacters !== formatCharacters) {\n            this.mask = new Mask(newMask, formatCharacters, useWhitespaces);\n            this.maskPattern = newMask;\n            this.formatCharacters = formatCharacters;\n        }\n    }\n\n    // eslint-disable-next-line complexity\n    private processInputEvent(event) {\n        if (this.props.onProcessInputEvent) {\n            this.props.onProcessInputEvent(event);\n        }\n\n        const prevSelection = this.input.selectionStart;\n        const newValue = event.target.value;\n\n        const currentValue = this.value;\n        const formattedValue = this.mask.format(newValue);\n\n        this.value = formattedValue;\n        // eslint-disable-next-line no-param-reassign\n        event.target.value = formattedValue;\n\n        // Если изменение поля ввода произошло не в конце ввода,\n        // то необходимо починить стандартное поведение Реакта и\n        // вернуть каретку к последнему изменению.\n        if (prevSelection <= currentValue.length) {\n            let newSelection = prevSelection;\n\n            // Определяем тип операции, который был произведен над текстовым полем.\n            let opType = newValue.length >= currentValue.length ? operationType.ADD : operationType.DELETE;\n\n            // На пользовательском инпуте было выделение перед операцией,\n            // значит могла быть операция или удаления или замены.\n            const beforeInputSelectionLength = this.beforeInputSelection.end - this.beforeInputSelection.start;\n\n            if (beforeInputSelectionLength >= 1) {\n                if (newValue.length !== currentValue.length - beforeInputSelectionLength) {\n                    opType = operationType.REPLACE;\n                }\n            }\n\n            const beforeChangeSeparatorsAmount = getSeparatorsAmount(\n                currentValue.slice(0, prevSelection),\n                this.beforeChangeMask,\n            );\n\n            const afterChangeSeparatorsAmount = getSeparatorsAmount(\n                formattedValue.slice(0, newSelection),\n                this.mask,\n            );\n\n            // Двигаем каретку вправо, если слева от каретки добавились не редактируемые символы\n            const shouldShiftCaret = beforeChangeSeparatorsAmount < afterChangeSeparatorsAmount\n                && (opType === operationType.ADD || opType === operationType.REPLACE)\n                && this.beforeChangeMask.isEditableIndex(this.beforeInputSelection.start)\n                && this.mask.isEditableIndex(newSelection);\n\n            // Двигаем каретку влево, если слева от каретки добавились не редактируемые символы\n            const shouldUnshiftCaret = beforeChangeSeparatorsAmount > afterChangeSeparatorsAmount\n                && opType === operationType.DELETE\n                && (this.mask.isEditableIndex(newSelection - 1) && newSelection > 0);\n\n            if (shouldUnshiftCaret || shouldShiftCaret) {\n                newSelection += (afterChangeSeparatorsAmount - beforeChangeSeparatorsAmount);\n            }\n\n            // Для операции добавления и замены, если мы стояли на нередактируемом символе,\n            // то добавляем сдвиг до ближайшего редактируемого.\n            if (opType === operationType.ADD || opType === operationType.REPLACE) {\n                let index = this.beforeInputSelection.start;\n\n                while (!this.beforeChangeMask.isEditableIndex(index) && index < formattedValue.length) {\n                    index += 1;\n                }\n                newSelection += index - this.beforeInputSelection.start;\n            }\n\n            // Если вдруг попали на нередактируемый символ маски,\n            // то подвигаем курсом до ближайшего редактируемого.\n            if (opType === operationType.ADD || opType === operationType.REPLACE) {\n                while (!this.mask.isEditableIndex(newSelection) && newSelection < formattedValue.length) {\n                    newSelection += 1;\n                }\n            } else if (opType === operationType.DELETE) {\n                while (!this.mask.isEditableIndex(newSelection - 1) && newSelection > 0) {\n                    newSelection -= 1;\n                }\n            }\n\n            // Положение каретки с учетом первого и последнего редактируемого символа маски.\n            const clampedSection = this.clampSelection(newSelection);\n\n            // Фикс бага смещения каретки в браузере на андроидах Jelly Bean (c 4.1 по 4.3)\n            const offsetSection = opType === operationType.ADD\n                && IS_ANDROID && parseFloat(getAndroidVersion() as string) < 4.4 ? 1 : 0;\n\n            this.setInputSelection(clampedSection + offsetSection);\n        } else if (IS_ANDROID) {\n            // Если изменение поля произошло в конце ввода.\n            // Android chrome имеет дефект с автоматической установкой каретки\n            // при использовании клавиатуры отличной от type=\"text\".\n            this.setInputSelectionByTimeout(event.target.selectionStart);\n        }\n\n        return event;\n    }\n\n    /**\n     * Возвращает положение каретки с учетом первого и последнего редактируемого символа маски.\n     *\n     * @param selection Положение каретки\n     */\n    private clampSelection(selection: number) {\n        if (selection < this.mask.firstEditableIndex) {\n            return this.mask.firstEditableIndex;\n        }\n\n        // +1 разрешает каретке становится в конец поля ввода при необходимости.\n        if (selection > this.mask.lastEditableIndex + 1) {\n            return this.mask.lastEditableIndex + 1;\n        }\n\n        return selection;\n    }\n\n    /**\n     * Устанавливает каретку поля ввода в новую позицию.\n     *\n     * @param selection Новое положение каретки\n     */\n    private setInputSelection(selection: number) {\n        this.input.selectionStart = selection;\n        this.input.selectionEnd = selection;\n\n        // IE10 не умеет синхронно в событие `change` переставлять каретку.\n        // Android chrome имеет дефект с автоматической установкой каретки\n        // при использовании клавиатуры отличной от type=\"text\".\n        if (IS_IE9_10 || IS_ANDROID) {\n            this.setInputSelectionByTimeout(selection);\n        }\n    }\n\n    /**\n     * Устанавливает каретку поля ввода в заданную позицию асинхронно.\n     *\n     * Во-избежание дефекта с установкой каретки, наблюдаемом в мобильных браузерах, а так же\n     * браузерах IE9-10, установка происходит асинхронно, с минимальной задержкой,\n     * с помощью [setTimeout] обертки.\n     *\n     * @param selection Положение каретки\n     */\n    private setInputSelectionByTimeout(selection: number) {\n        if (this.caretFixTimeout) {\n            clearTimeout(this.caretFixTimeout);\n            this.caretFixTimeout = null;\n        }\n\n        this.caretFixTimeout = setTimeout(() => {\n            this.caretFixTimeout = null;\n            this.input.selectionStart = selection;\n            this.input.selectionEnd = selection;\n        }, 0);\n    }\n}\n\nexport default MaskedInput;\n"]}