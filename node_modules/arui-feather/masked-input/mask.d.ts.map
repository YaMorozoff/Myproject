{"version":3,"sources":["masked-input/mask.ts"],"names":[],"mappings":"AAcA,aAAK,aAAa,GAAG;IACjB,QAAQ,EAAE,CAAC,IAAI,EAAE,MAAM,KAAK,OAAO,CAAC;IACpC,SAAS,CAAC,EAAE,CAAC,IAAI,EAAE,MAAM,KAAK,MAAM,CAAC;CACxC,CAAC;AAEF,oBAAY,gBAAgB,GAAG;IAC3B,CAAC,GAAG,EAAE,MAAM,GAAG,aAAa,CAAC;CAChC,CAAC;AAoCF;;GAEG;AACH,cAAM,IAAI;IACN;;OAEG;IACH,MAAM,EAAE,MAAM,CAAC;IAEf;;OAEG;IACH,kBAAkB,EAAE,MAAM,CAAC;IAE3B;;OAEG;IACH,iBAAiB,EAAE,MAAM,CAAC;IAG1B,OAAO,EAAE,GAAG,CAAC;IAEb;;OAEG;IACH,cAAc,EAAE,OAAO,CAAC;IAExB;;;OAGG;gBACS,IAAI,EAAE,MAAM,EAAE,gBAAgB,CAAC,EAAE,gBAAgB,EAAE,cAAc,CAAC,EAAE,OAAO;IAavF;;;;OAIG;IACH,eAAe,CAAC,KAAK,EAAE,MAAM;IAI7B;;;;OAIG;IACH,MAAM,CAAC,KAAK,EAAE,MAAM;CAqCvB;AAED,eAAe,IAAI,CAAC","file":"mask.d.ts","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport InputMask from 'inputmask-core';\n\n// Стандартный плейсхолдер буквы равный по ширине цифровому символу.\nconst PLACEHOLDER_CHAR = '\\u2007';\n\n// Стандартные formatCharacters из inputmask-core.\nconst DIGIT_RE = /^\\d$/;\nconst LETTER_RE = /^[A-Za-z]$/;\nconst ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/;\n\ntype CharFormatter = {\n    validate: (char: string) => boolean;\n    transform?: (char: string) => string;\n};\n\nexport type FormatCharacters = {\n    [key: string]: CharFormatter;\n};\n\nconst DEFAULT_FORMAT_CHARACTERS: FormatCharacters = {\n    '*': {\n        validate(char) {\n            return ALPHANNUMERIC_RE.test(char);\n        },\n    },\n    1: {\n        validate(char) {\n            return DIGIT_RE.test(char);\n        },\n    },\n    a: {\n        validate(char) {\n            return LETTER_RE.test(char);\n        },\n    },\n    A: {\n        validate(char) {\n            return LETTER_RE.test(char);\n        },\n        transform(char) {\n            return char.toUpperCase();\n        },\n    },\n    '#': {\n        validate(char) {\n            return ALPHANNUMERIC_RE.test(char);\n        },\n        transform(char) {\n            return char.toUpperCase();\n        },\n    },\n};\n\n/**\n * Класс маски. Позволяет форматировать строку по заданной маске.\n */\nclass Mask {\n    /**\n     * Длина маски.\n     */\n    length: number;\n\n    /**\n     * Индекс первого редактируемого символа.\n     */\n    firstEditableIndex: number;\n\n    /**\n     * Индекс последнего редактируемого символа.\n     */\n    lastEditableIndex: number;\n\n    // TODO: install InputMask typings\n    pattern: any;\n\n    /**\n     * Признак что пробелы удалять не надо\n     */\n    useWhitespaces: boolean;\n\n    /**\n     * @param mask Маска в формате: https://github.com/insin/inputmask-core\n     * @param formatCharacters Форматтеры маски в формате `inputmask-core`\n     */\n    constructor(mask: string, formatCharacters?: FormatCharacters, useWhitespaces?: boolean) {\n        this.pattern = new InputMask.Pattern(\n            mask,\n            { ...DEFAULT_FORMAT_CHARACTERS, ...formatCharacters },\n            PLACEHOLDER_CHAR,\n        );\n\n        this.length = this.pattern.length;\n        this.firstEditableIndex = this.pattern.firstEditableIndex;\n        this.lastEditableIndex = this.pattern.lastEditableIndex;\n        this.useWhitespaces = useWhitespaces || false;\n    }\n\n    /**\n     * Проверяет является ли символ в заданном индексе редактируемым.\n     *\n     * @param index Индекс символа.\n     */\n    isEditableIndex(index: number) {\n        return this.pattern.isEditableIndex(index);\n    }\n\n    /**\n     * Форматирует значение введенное в поле ввода по маске.\n     *\n     * @param value Неформатированное значение из поля ввода.\n     */\n    format(value: string) {\n        let formattedValue = '';\n\n        const cleanValue = this.useWhitespaces ? value : value.replace(/\\s+/g, '');\n        const cleanValueLength = cleanValue.length;\n        let cleanValueIndex = 0;\n        let cleanValueChar;\n\n        let patternIndex = 0;\n        let patternChar;\n        const patternLength = this.pattern.length;\n\n        while (patternIndex < patternLength && cleanValueIndex < cleanValueLength) {\n            if (this.pattern.isEditableIndex(patternIndex)) {\n                // eslint-disable-next-line no-cond-assign\n                while ((cleanValueChar = cleanValue.charAt(cleanValueIndex)) !== '') {\n                    if (this.pattern.isValidAtIndex(cleanValueChar, patternIndex)) {\n                        formattedValue += this.pattern.transform(cleanValueChar, patternIndex);\n                        patternIndex += 1;\n                        cleanValueIndex += 1;\n                        break;\n                    } else {\n                        cleanValueIndex += 1;\n                    }\n                }\n            } else {\n                patternChar = this.pattern.pattern[patternIndex];\n                formattedValue += patternChar;\n                patternIndex += 1;\n                if (cleanValue.charAt(cleanValueIndex) === patternChar) {\n                    cleanValueIndex += 1;\n                }\n            }\n        }\n\n        return formattedValue;\n    }\n}\n\nexport default Mask;\n"]}