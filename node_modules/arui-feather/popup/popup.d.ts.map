{"version":3,"sources":["popup/popup.tsx"],"names":[],"mappings":"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","file":"popup.d.ts","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/* eslint-disable max-len */\n\nimport debounce from 'lodash.debounce';\nimport React from 'react';\nimport Type, { ValidationMap } from 'prop-types';\nimport ReactDOM from 'react-dom';\nimport { createCn } from 'bem-react-classname';\nimport { withTheme } from '../cn';\nimport { ResizeSensor } from '../resize-sensor/resize-sensor';\n\nimport { calcBestDrawingParams, calcTargetDimensions, calcFitContainerDimensions } from './calc-drawing-params';\nimport { HtmlElement } from '../lib/prop-types';\nimport { isNodeOutsideElement } from '../lib/window';\nimport performance from '../performance';\n\n// TODO: решить че с этим делать потому что вроде как отдельная структура не нужна\n/**\n * @typedef {Object} Point\n * @property {Number} left Координата по оси x\n * @property {Number} top Координата по оси y\n */\n\n/**\n * @typedef {Object} PopupOffsetCollection\n * @property {Number} main Смещение в пикселях всплывающего окна относительно основного направления\n * @property {Number} second Смещение в пикселях всплывающего окна относительно второстепенного направления\n * @property {Number} viewport Минимально допустимое смещение в пикселях всплывающего окна от края окна браузера\n */\n\n/**\n * @typedef {Object} PopupHash\n * @property {Array.<String>} directions Список возмножных расположений попапа\n * @property {String} bestDirection Приоритетное расположение\n * @property {Boolean} isHeightAdaptive Подстраивается ли высота попапа под край окна\n * @property {Boolean} isHeightAvailable Занимает ли попап всю возможную высоту\n * @property {Boolean} isTargetAnchor Привязан ли попап к другому элементу\n * @property {Boolean} isHaveTooltip Имеет ли попап тип \"tooltip\"\n * @property {Number} width Ширина попапа\n * @property {Number} height Высота попапа\n * @property {Number} contentWidth Ширина контента в попапе\n * @property {Number} contentHeight Высота контента в попапе\n * @property {PopupOffsetCollection} offset Список смещений попапа\n * @property {Point} targetPosition Координаты точки привязки попапа\n * @property {HTMLElement} targetAnchor Объект элемента, к которому привязан попап, в DOM дереве\n */\n\nexport type PopupDirectionsFieldType = 'anchor' | 'top-left' | 'top-center' | 'top-right' | 'left-top' | 'left-center' | 'left-bottom' | 'right-top' | 'right-center' | 'right-bottom' | 'bottom-left' | 'bottom-center' | 'bottom-right';\n\nexport type PopupProps = {\n\n    /**\n     * Дополнительный класс\n     */\n    className?: string;\n\n    /**\n     * Идентификатор компонента в DOM\n     */\n    id?: string;\n\n    /**\n     * Дочерние элементы `Popup`\n     */\n    children?: React.ReactNode;\n\n    /**\n     * Тип попапа\n     */\n    type?: 'default' | 'tooltip';\n\n    /**\n     * Подстраивание высоты попапа под край окна ('adaptive'), занятие попапом всей возможной высоты ('available'), 'default'\n     */\n    height?: 'default' | 'available' | 'adaptive';\n\n    /**\n     * Только для target='anchor', расположение (в порядке приоритета) относительно точки открытия. Первым указывается главное направление, через дефис - второстепенное направление\n     */\n    directions?: readonly PopupDirectionsFieldType[];\n\n    /**\n     * Привязка компонента к другому элементу на странице, или его расположение независимо от остальных: 'anchor', 'position', 'screen'\n     */\n    target?: 'anchor' | 'position' | 'screen';\n\n    /**\n     * Только для target='anchor'. Смещение в пикселях всплывающего окна относительно основного направления\n     */\n    mainOffset?: number;\n\n    /**\n     * Только для target='anchor'. Смещение в пикселях всплывающего окна относительно второстепенного направления\n     */\n    secondaryOffset?: number;\n\n    /**\n     * Только для target='anchor'. Минимально допустимое смещение в пикселях всплывающего окна от края его контейнера\n     */\n    fitContaiterOffset?: number;\n\n    /**\n     * Управление видимостью компонента\n     */\n    visible?: boolean;\n\n    /**\n     * Управление выставлением модификатора для добавления внутренних отступов в стилях\n     */\n    padded?: boolean;\n\n    /**\n     * Элемент закреплённого заголовка для компонента\n     */\n    header?: React.ReactNode;\n\n    /**\n     * Размер компонента\n     */\n    size?: 's' | 'm' | 'l' | 'xl';\n\n    /**\n     * Тема компонента\n     */\n    theme?: 'alfa-on-color' | 'alfa-on-white';\n\n    /**\n     * Обработчик события наведения курсора на попап\n     */\n    onMouseEnter?: (event?: React.MouseEvent<any>) => void;\n\n    /**\n     * Обработчик события снятия курсора с попапа\n     */\n    onMouseLeave?: (event?: React.MouseEvent<any>) => void;\n\n    /**\n     * Обработчик клика вне компонента\n     */\n    onClickOutside?: (event?: React.MouseEvent<any>) => void;\n\n    /**\n     * Минимальная ширина попапа\n     */\n    minWidth?: number;\n\n    /**\n     * Максимальная ширина попапа\n     */\n    maxWidth?: number;\n\n    /**\n     * Максимальная высота попапа\n     */\n    maxHeight?: number;\n\n    /**\n     * Указатель на родительский элемент\n     */\n    for?: string;\n\n    /**\n     * Идентификатор для систем автоматизированного тестирования\n     */\n    'data-test-id'?: string;\n};\n\ntype PopupState = {\n    direction: any;\n    hasScrollbar: boolean;\n    receivedContainer: boolean;\n    styles: React.CSSProperties;\n    topGradientStyles: React.CSSProperties;\n    bottomGradientStyles: React.CSSProperties;\n    canUseDOM: boolean;\n    needRedrawAfterMount: boolean;\n};\n\nexport const popupContextTypes: ValidationMap<unknown> = {\n    isInCustomContainer: Type.bool,\n    renderContainerElement: HtmlElement,\n    positioningContainerElement: HtmlElement,\n};\n\n/**\n * Компонент popup'а.\n */\n@performance(true)\nexport class Popup extends React.Component<PopupProps, PopupState> {\n    protected cn = createCn('popup');\n\n    static defaultProps: Partial<PopupProps> = {\n        visible: false,\n        padded: true,\n        secondaryOffset: 0,\n        fitContaiterOffset: 0,\n        target: 'anchor',\n        size: 's',\n    };\n\n    static contextTypes = popupContextTypes;\n\n    state = {\n        direction: null,\n        hasScrollbar: false,\n        receivedContainer: false,\n        styles: {\n            top: 0,\n            left: 0,\n            height: 'auto',\n        },\n        topGradientStyles: {\n            width: '100%',\n        },\n        bottomGradientStyles: {\n            width: '100%',\n        },\n        canUseDOM: false,\n        /*\n         * Переменная для отложенного вызова функции redraw(),\n         * которая будет вызвана после вызова componentDidMount().\n         */\n        needRedrawAfterMount: false,\n    };\n\n    private anchor = null;\n\n    private clickEventBindTimeout = null;\n\n    private domElemPopup = null;\n\n    private domElemPopupInner: HTMLElement = null;\n\n    private domElemPopupContent = null;\n\n    private isWindowClickBinded = false;\n\n    private position = null;\n\n    private popup;\n\n    private inner;\n\n    private content;\n\n    private handleWindowResize = debounce(() => {\n        if (this.isPropsToPositionCorrect()) {\n            this.redraw();\n        }\n    }, 200);\n\n    // eslint-disable-next-line camelcase\n    UNSAFE_componentWillMount() {\n        if (\n            this.context.isInCustomContainer\n            && this.context.renderContainerElement\n            && this.context.positioningContainerElement\n        ) {\n            this.setState({\n                receivedContainer: true,\n            });\n        }\n    }\n\n    componentDidMount() {\n        if (this.props.onClickOutside) {\n            this.ensureClickEvent();\n        }\n\n        if (this.inner && (this.props.height === 'adaptive' || this.props.target === 'screen')) {\n            this.setGradientStyles();\n        }\n\n        window.addEventListener('resize', this.handleWindowResize);\n\n        /* eslint-disable react/no-did-mount-set-state */\n        this.setState(\n            {\n                canUseDOM: true,\n            },\n            () => {\n                if (this.state.needRedrawAfterMount) {\n                    this.redraw();\n                }\n            },\n        );\n        /* eslint-enable */\n    }\n\n    // eslint-disable-next-line camelcase\n    UNSAFE_componentWillReceiveProps(nextProps, nextContext) {\n        if (\n            !this.state.receivedContainer\n            && nextContext.renderContainerElement\n            && nextContext.positioningContainerElement\n        ) {\n            this.setState(\n                {\n                    receivedContainer: true,\n                },\n                () => {\n                    if (this.props.visible) {\n                        this.redraw();\n                    }\n                },\n            );\n\n            return;\n        }\n\n        if (nextProps.visible !== this.props.visible) {\n            this.redraw();\n        }\n    }\n\n    componentDidUpdate(prevProps) {\n        if (this.props.onClickOutside) {\n            if (prevProps.onClickOutside !== this.props.onClickOutside) {\n                this.ensureClickEvent();\n            } else if (prevProps.visible !== this.props.visible) {\n                this.ensureClickEvent(!this.props.visible);\n            }\n        }\n    }\n\n    componentWillUnmount() {\n        if (this.props.onClickOutside) {\n            this.ensureClickEvent(true);\n        }\n\n        // Cancel debouncing to avoid `this.setState()` invocation in unmounted component state\n        this.handleWindowResize.cancel();\n        window.removeEventListener('resize', this.handleWindowResize);\n    }\n\n    render() {\n        if (!this.state.canUseDOM || !this.isContainerReady()) {\n            return null;\n        }\n\n        const template = (\n            <div\n                ref={ (popup) => {\n                    this.popup = popup;\n                } }\n                data-for={ this.props.for }\n                className={ this.cn({\n                    direction: this.state.direction,\n                    type: this.props.target === 'anchor' && this.props.type === 'tooltip' && this.props.type,\n                    target: this.props.target,\n                    size: this.props.size,\n                    visible: this.props.visible,\n                    height: this.props.height,\n                    padded: this.props.padded,\n                    overflow: !!this.props.maxHeight,\n                }) }\n                id={ this.props.id }\n                style={ {\n                    ...this.state.styles,\n                    minWidth: this.getMinWidth(),\n                    maxWidth: this.getMaxWidth(),\n                    maxHeight: this.getMaxHeight(),\n                } }\n                onMouseEnter={ this.handleMouseEnter }\n                onMouseLeave={ this.handleMouseLeave }\n                data-test-id={ this.props['data-test-id'] }\n            >\n                <div className={ this.cn('container') }>\n                    { this.props.header && <div className={ this.cn('header') }>{ this.props.header }</div> }\n                    <div\n                        ref={ (inner) => {\n                            this.inner = inner;\n                        } }\n                        className={ this.cn('inner') }\n                        onScroll={ this.handleInnerScroll }\n                    >\n                        <div\n                            className={ this.cn('content') }\n                            ref={ (content) => {\n                                this.content = content;\n                            } }\n                        >\n                            { this.props.children }\n                            <ResizeSensor onResize={ this.handleResize } />\n                        </div>\n                    </div>\n                    { this.state.hasScrollbar && (\n                        <div>\n                            <div className={ this.cn('gradient', { top: true }) } style={ this.state.topGradientStyles } />\n                            <div\n                                className={ this.cn('gradient', { bottom: true }) }\n                                style={ this.state.bottomGradientStyles }\n                            />\n                        </div>\n                    ) }\n                </div>\n            </div>\n        );\n\n        return ReactDOM.createPortal(template, this.getRenderContainer());\n    }\n\n    private handleInnerScroll = (event) => {\n        const { scrollTop, offsetHeight, scrollHeight } = event.target;\n        const isTopReached = Math.round(scrollTop) === 0;\n        const isBottomReached = Math.round(scrollTop) + offsetHeight === scrollHeight;\n\n        if (this.props.height === 'adaptive' || this.props.target === 'screen') {\n            const topGradientStyles: {\n                width: string;\n                height?: number;\n            } = {\n                // eslint-disable-next-line react/no-access-state-in-setstate\n                width: this.state.topGradientStyles.width,\n            };\n            const bottomGradientStyles: {\n                width: string;\n                height?: number;\n            } = {\n                // eslint-disable-next-line react/no-access-state-in-setstate\n                width: this.state.bottomGradientStyles.width,\n            };\n\n            if (isTopReached) {\n                topGradientStyles.height = 0;\n            }\n\n            if (isBottomReached) {\n                bottomGradientStyles.height = 0;\n            }\n\n            this.setState({\n                topGradientStyles,\n                bottomGradientStyles,\n            });\n        }\n    };\n\n    private handleMouseEnter = (event) => {\n        if (this.props.onMouseEnter) {\n            this.props.onMouseEnter(event);\n        }\n    };\n\n    private handleMouseLeave = (event) => {\n        if (this.props.onMouseLeave) {\n            this.props.onMouseLeave(event);\n        }\n    };\n\n    private handleWindowClick = (event) => {\n        if (this.props.onClickOutside && !!this.domElemPopup && isNodeOutsideElement(event.target, this.domElemPopup)) {\n            this.props.onClickOutside(event);\n        }\n    };\n\n    private handleResize = () => {\n        if (!this.props.visible) {\n            return;\n        }\n\n        this.redraw();\n    };\n\n    /**\n     * Задает элемент, к которому будет привязан popup.\n     * @param target Элемент, к которому будет привязан popup\n     */\n    public setTarget(target: HTMLElement) {\n        if (this.anchor === target) {\n            return;\n        }\n\n        this.anchor = target;\n        this.redraw();\n    }\n\n    /**\n     * Задает положение popup.\n     * @param left x-coordinate\n     * @param top y-coordinate\n     */\n    public setPosition(left: number, top: number) {\n        this.position = { left, top };\n        this.redraw();\n    }\n\n    /**\n     * Возвращает внутренний DOM узел.\n     */\n    public getInnerNode() {\n        return this.domElemPopupInner;\n    }\n\n    /**\n     * Возвращает контейнер, в котором отрендерится попап.\n     */\n    private getRenderContainer(): HTMLElement {\n        if (!this.context.isInCustomContainer) {\n            return document.body;\n        }\n\n        return this.context.renderContainerElement;\n    }\n\n    /**\n     * Возвращает контейнер, внутрь которого надо вписать элемент.\n     */\n    private getPositioningContainer(): HTMLElement {\n        if (!this.context.isInCustomContainer) {\n            return null;\n        }\n\n        return this.context.positioningContainerElement;\n    }\n\n    /**\n     * Возвращает `true`, если контейнер, в котором должен быть отрисован\n     * `Popup` уже находится в DOM. Для `Popup` без кастомного контейнера\n     * роль контейнера выполняет `document.body` и этот для них этот метод\n     * всегда вернете `true`.\n     */\n    private isContainerReady() {\n        if (!this.context.isInCustomContainer) {\n            return true;\n        }\n\n        return this.context.isInCustomContainer && this.state.receivedContainer;\n    }\n\n    /**\n     * Возвращает `true`, если все необходимые для расчета положения `Popup`\n     * внешние props заданы.\n     */\n    isPropsToPositionCorrect(): boolean {\n        return (\n            (this.props.target === 'anchor' && this.anchor)\n            || (this.props.target === 'position' && this.position)\n            || this.props.target === 'screen'\n        );\n    }\n\n    private redraw = () => {\n        /*\n         * Если функция redraw() была вызвана до componentDidMount,\n         * то нужно отложить её вызов до момента,\n         * когда this.state.canUseDOM будет равен значению true.\n         *\n         * Это сделано для того, чтобы redraw() не вызывалась на серверной стороне.\n         */\n        this.setState({\n            needRedrawAfterMount: true,\n        });\n\n        if (!this.state.canUseDOM || !this.isContainerReady()) {\n            return;\n        }\n\n        this.setState({\n            needRedrawAfterMount: false,\n        });\n\n        if (!this.isPropsToPositionCorrect()) {\n            throw new Error('Cannot show popup without target or position');\n        }\n\n        if (!this.domElemPopup) {\n            this.domElemPopup = this.popup;\n            this.domElemPopupInner = this.inner;\n            this.domElemPopupContent = this.content;\n        }\n\n        const popupHash = this.getPopupHash();\n        let bestDrawingParams;\n\n        switch (this.props.target) {\n        case 'position':\n            bestDrawingParams = { top: this.position.top, left: this.position.left };\n            break;\n\n        case 'screen':\n            bestDrawingParams = {\n                top: 0,\n                left: 0,\n                right: 0,\n                bottom: 0,\n                overflow: this.inner.scrollHeight > this.inner.clientHeight,\n            };\n            break;\n\n        case 'anchor':\n            bestDrawingParams = calcBestDrawingParams(\n                popupHash,\n                calcTargetDimensions(popupHash),\n                calcFitContainerDimensions(popupHash),\n            );\n            break;\n        }\n\n        this.setState({\n            direction: bestDrawingParams.direction,\n            hasScrollbar: bestDrawingParams.overflow,\n            styles: this.getDrawingCss(bestDrawingParams),\n        });\n\n        this.setGradientStyles();\n    };\n\n    private ensureClickEvent(isDestroy?) {\n        const isNeedBindEvent = isDestroy === undefined ? this.props.visible : !isDestroy;\n\n        // We need timeouts to not to catch the event that causes\n        // popup opening (because it propagates to the `window`).\n        if (this.clickEventBindTimeout) {\n            clearTimeout(this.clickEventBindTimeout);\n            this.clickEventBindTimeout = null;\n        }\n\n        this.clickEventBindTimeout = setTimeout(() => {\n            if (!this.isWindowClickBinded && isNeedBindEvent) {\n                window.addEventListener('click', this.handleWindowClick);\n                window.addEventListener('touchend', this.handleWindowClick);\n                this.isWindowClickBinded = true;\n            } else if (this.isWindowClickBinded && !isNeedBindEvent) {\n                window.removeEventListener('click', this.handleWindowClick);\n                window.removeEventListener('touchend', this.handleWindowClick);\n                this.isWindowClickBinded = false;\n            }\n        }, 0);\n    }\n\n    private getDrawingCss(drawingParams) {\n        return {\n            top: drawingParams.top,\n            left: drawingParams.left,\n            right: drawingParams.right,\n            bottom: drawingParams.bottom,\n            height: this.props.height === 'adaptive' ? drawingParams.height : 'auto',\n        };\n    }\n\n    private getMinWidth() {\n        return this.props.minWidth === undefined ? 0 : this.props.minWidth;\n    }\n\n    private getMaxWidth() {\n        return this.props.maxWidth === undefined ? 'none' : this.props.maxWidth;\n    }\n\n    private getMaxHeight() {\n        return this.props.maxHeight === undefined ? 'none' : this.props.maxHeight;\n    }\n\n    /**\n     * Get collection of popup properties.\n     *\n     */\n    private getPopupHash() {\n        return {\n            directions: this.props.directions,\n            bestDirection: this.state.direction,\n            isHeightAdaptive: this.props.height === 'adaptive',\n            isHeightAvailable: this.props.height === 'available',\n            isTargetAnchor: this.props.target === 'anchor',\n            isHaveTooltip: this.props.type === 'tooltip',\n            width: this.domElemPopup.offsetWidth,\n            height: this.domElemPopup.offsetHeight,\n            contentWidth: this.domElemPopupContent.offsetWidth,\n            contentHeight: this.domElemPopupContent.offsetHeight,\n            offset: {\n                main: this.props.mainOffset,\n                second: this.props.secondaryOffset,\n                fitContainer: this.props.fitContaiterOffset,\n            },\n            targetPosition: this.position,\n            targetAnchor: this.anchor,\n            fitContainer: this.getPositioningContainer(),\n        };\n    }\n\n    private setGradientStyles() {\n        const { clientWidth } = this.inner;\n\n        this.setState({\n            topGradientStyles: {\n                width: clientWidth,\n                height: 0,\n            },\n            bottomGradientStyles: {\n                width: clientWidth,\n            },\n        });\n    }\n}\n\nexport default withTheme<PopupProps, Popup>(Popup);\n"]}