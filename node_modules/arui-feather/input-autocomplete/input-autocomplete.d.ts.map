{"version":3,"sources":["input-autocomplete/input-autocomplete.tsx"],"names":[],"mappings":"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","file":"input-autocomplete.d.ts","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// @ts-nocheck\n\n/* eslint react/prop-types: 0 */\n\nimport React from 'react';\nimport { createCn } from 'bem-react-classname';\nimport { withTheme } from '../cn';\nimport { FormatCharacters } from '../masked-input/mask';\n\nimport Menu from '../menu/menu';\nimport Popup from '../popup/popup';\nimport { ResizeSensor } from '../resize-sensor/resize-sensor';\n\nimport keyboardCode from '../lib/keyboard-code';\nimport performance from '../performance';\nimport scrollTo from '../lib/scroll-to';\nimport { SCROLL_TO_NORMAL_DURATION } from '../vars';\n\nimport { MenuItem } from '../menu-item/menu-item';\nimport Input, { InputProps } from '../input/input';\n\nexport type InputAutocompleteProps = InputProps & {\n\n    /**\n     * Тип поля.\n     * Внимание, тип 'number' не умеет работать с масками, в том числе с 'selectionStart' и 'selectionEnd'.\n     * Подробнее: <a href=\"http://w3c.github.io/html/sec-forms.html#does-not-apply\" target=\"_blank\">http://w3c.github.io/html/sec-forms.html#does-not-apply</a>\n     */\n    type?: 'number' | 'card' | 'email' | 'file' | 'hidden' | 'money' | 'password' | 'tel' | 'text';\n\n    /**\n     * Тип инпута (filled только на белом фоне в размере m)\n     */\n    view?: 'default' | 'filled';\n\n    /**\n     * Управление возможностью компонента занимать всю ширину родителя\n     */\n    width?: 'default' | 'available';\n\n    /**\n     * Управление автозаполнением компонента. В случае передачи `true` или `false` подставляет `on` или `off`.\n     * Строка подставляется как есть.\n     */\n    autocomplete?: boolean | string;\n\n    /**\n     * Управление возможностью изменения атрибута компонента, установка\n     * соответствующего класса-модификатора для оформления\n     */\n    disabled?: boolean;\n\n    /**\n     * Управление возможностью изменения атрибута компонента (без установки класса-модификатора для оформления)\n     */\n    disabledAttr?: boolean;\n\n    /**\n     * Управление возможностью изменения класса-модификатора компонента\n     */\n    focused?: boolean;\n\n    /**\n     * Максимальное число символов\n     */\n    maxLength?: number;\n\n    /**\n     * Иконка компонента\n     */\n    icon?: React.ReactNode;\n\n    /**\n     * Управление наличием крестика, сбрасывающего значение 'value'\n     */\n    clear?: boolean;\n\n    /**\n     * Уникальный идентификатор блока\n     */\n    id?: string;\n\n    /**\n     * Уникальное имя блока\n     */\n    name?: string;\n\n    /**\n     * Содержимое поля ввода\n     */\n    value?: string;\n\n    /**\n     * Содержимое поля ввода, указанное по умолчанию\n     */\n    defaultValue?: string;\n\n    /**\n     * Последовательность перехода между контролами при нажатии на Tab\n     */\n    tabIndex?: number;\n\n    /**\n     * Определяет маску для ввода значений. <a href=\"https://github.com/insin/inputmask-core#pattern\" target=\"_blank\">Шаблон маски</a>\n     */\n    mask?: string;\n\n    /**\n     * Позволяет использовать пробелы в маске\n     */\n    useWhitespacesInMask?: boolean;\n\n    /**\n     * Кастомные форматтеры символов маски, использует формат formatCharacters из `inputmask-core`\n     */\n    maskFormatCharacters?: FormatCharacters;\n\n    /**\n     * Стандартное ствойство HTMLInputElement 'pattern'. Может быть использовано для показа корректной клавиатуры на мобильных устройствах.\n     */\n    pattern?: string;\n\n    /**\n     * Управление встроенной проверкой данных введённых пользователем в поле на корректность\n     */\n    formNoValidate?: boolean;\n\n    /**\n     * Добавление дополнительных элементов к инпуту слева\n     */\n    leftAddons?: React.ReactNode;\n\n    /**\n     * Добавление дополнительных элементов к инпуту справа\n     */\n    rightAddons?: React.ReactNode;\n\n    /**\n     * Лейбл для поля\n     */\n    label?: React.ReactNode;\n\n    /**\n     * Подсказка в поле\n     */\n    placeholder?: string;\n\n    /**\n     * Подсказка под полем\n     */\n    hint?: React.ReactNode;\n\n    /**\n     * Отображение ошибки\n     */\n    error?: React.ReactNode;\n\n    /**\n     * Сброс ошибки при установке фокуса\n     */\n    resetError?: boolean;\n\n    /**\n     * Размер компонента\n     */\n    size?: 's' | 'm' | 'l' | 'xl';\n\n    /**\n     * Тема компонента\n     */\n    theme?: 'alfa-on-color' | 'alfa-on-white';\n\n    /**\n     * Дополнительный класс\n     */\n    className?: string;\n\n    /**\n     * Тултип, который появляется при наведении\n     */\n    title?: string;\n\n    /**\n     * Обработчик изменения значения 'value'\n     */\n    onChange?: (value?: string) => void;\n\n    /**\n     * Обработчик фокуса поля\n     */\n    onFocus?: (event?: React.FocusEvent<any>) => void;\n\n    /**\n     * Обработчик клика по полю\n     */\n    onClick?: (event?: React.MouseEvent<any>) => void;\n\n    /**\n     * Обработчик снятия фокуса с поля\n     */\n    onBlur?: (event?: React.FocusEvent<any>) => void;\n\n    /**\n     * Обработчик клика по крестику сбрасываещему значение 'value'\n     */\n    onClearClick?: (event?: React.MouseEvent<any>) => void;\n\n    /**\n     * Обработчик события нажатия на клавишу клавиатуры в момент, когда фокус находится на компоненте\n     */\n    onKeyDown?: (event?: React.KeyboardEvent<any>) => void;\n\n    /**\n     * Обработчик события отжатия на клавишу клавиатуры в момент, когда фокус находится на компоненте\n     */\n    onKeyUp?: (event?: React.KeyboardEvent<any>) => void;\n\n    /**\n     * Обработчик события вставки текста в поле\n     */\n    onPaste?: (event?: React.ClipboardEvent<any>) => void;\n\n    /**\n     * Обработчик события касания по полю\n     */\n    onTouchStart?: (event?: React.TouchEvent<any>) => void;\n\n    /**\n     * Обработчик события прекращения касания по полю\n     */\n    onTouchEnd?: (event?: React.TouchEvent<any>) => void;\n\n    /**\n     * Обработчик события перемещения при касании по полю\n     */\n    onTouchMove?: (event?: React.TouchEvent<any>) => void;\n\n    /**\n     * Обработчик события прерывания касания по полю\n     */\n    onTouchCancel?: (event?: React.TouchEvent<any>) => void;\n\n    /**\n     * Обработчик, вызываемый перед началом ввода в маскированное поле\n     */\n    onProcessMaskInputEvent?: (event?: React.ChangeEvent<any>) => void;\n\n    /**\n     * Идентификатор для систем автоматизированного тестирования\n     */\n    'data-test-id'?: string;\n\n    /**\n     * Список вариантов выбора\n     */\n    options?: ReadonlyArray<{\n\n        /**\n         * Тип списка вариантов\n         */\n        type?: 'item' | 'group';\n\n        /**\n         * Уникальное значение, которое будет отправлено на сервер, если вариант выбран\n         */\n        value?: string;\n\n        /**\n         * Отображение варианта\n         */\n        description?: React.ReactNode;\n\n        /**\n         * Текст, который должен быть записан в текстовое поле при выборе варианта\n         */\n        text?: string;\n\n        /**\n         * Список вариантов, только для type='group'\n         */\n        content?: any[];\n\n        /**\n         * Только для type='item': свойства для компонента [MenuItem](#!/MenuItem)\n         */\n        props?: object;\n    }>;\n\n    /**\n     * Управление видимостью выпадающего списка\n     */\n    opened?: boolean;\n\n    /**\n     * Ширинa выпадающего списка равна ширине инпута\n     */\n    equalPopupWidth?: boolean;\n\n    /**\n     * Определяет нужно или нет обновлять значение текстового поля при выборе варианта\n     */\n    updateValueOnItemSelect?: boolean;\n\n    /**\n     * Направления, в которые может открываться попап компонента\n     */\n    directions?: ReadonlyArray<'top-left' | 'top-center' | 'top-right' | 'left-top' | 'left-center' | 'left-bottom' | 'right-top' | 'right-center' | 'right-bottom' | 'bottom-left' | 'bottom-center' | 'bottom-right'>;\n\n    /**\n     * Вставляет попап со списком только если элемент активен\n     */\n    renderPopupOnFocus?: boolean;\n\n    /**\n     * Обработчик выбора пункта в выпадающем меню\n     */\n    onItemSelect?: (checkedItem?: any) => void;\n\n    /**\n     * Закрытие выпадающего списка в случае, если произошел выбор элемента\n     */\n    closeOnSelect?: boolean;\n\n    /**\n     * Максимальная высота выпадающего списка опций\n     */\n    popupMaxHeight?: number;\n\n    /**\n     * Название класса попапа с опциями\n     */\n    popupClassName?: string;\n};\n\ntype InputAutocompleteState = {\n    value: string;\n    inputFocused: boolean;\n    menuFocused: boolean;\n    popupStyles: React.CSSProperties;\n    highlightedItem: MenuItem | null;\n}\n\n/**\n * Компонент поля для ввода с автокомплитом.\n *\n * @extends Input\n */\n@performance(true)\nexport class InputAutocomplete extends React.Component<InputAutocompleteProps, InputAutocompleteState> {\n    protected cn = createCn('input');\n\n    static defaultProps: Partial<InputAutocompleteProps> = {\n        disabled: false,\n        size: 'm',\n        width: 'default',\n        options: [],\n        updateValueOnItemSelect: true,\n        directions: ['bottom-left', 'bottom-right', 'top-left', 'top-right'],\n        equalPopupWidth: false,\n        closeOnSelect: false,\n        renderPopupOnFocus: false,\n    };\n\n    state = {\n        value: this.props.defaultValue || '',\n        inputFocused: false,\n        menuFocused: false,\n        popupStyles: {},\n        highlightedItem: null,\n    };\n\n    private input: Input;\n\n    private popup: Popup;\n\n    private menu: Menu;\n\n    private blurTimeout: ReturnType<typeof setTimeout> = null;\n\n    private inputFocusTimeout: ReturnType<typeof setTimeout> = null;\n\n    componentDidMount() {\n        this.updatePopupTarget();\n        this.updatePopupStyles();\n    }\n\n    componentDidUpdate() {\n        this.updatePopupTarget();\n        this.updatePopupStyles();\n    }\n\n    componentWillUnmount() {\n        if (this.blurTimeout) {\n            clearTimeout(this.blurTimeout);\n            this.blurTimeout = null;\n        }\n\n        if (this.inputBlurTimeout) {\n            clearTimeout(this.inputBlurTimeout);\n            this.inputBlurTimeout = null;\n        }\n\n        if (this.inputFocusTimeout) {\n            clearTimeout(this.inputFocusTimeout);\n            this.inputFocusTimeout = null;\n        }\n    }\n\n    render() {\n        const value = this.props.value === undefined ? this.state.value : this.props.value;\n\n        const props = {\n            ...this.props,\n            ref: (input) => {\n                this.input = input;\n            },\n            className: this.cn({\n                focused: this.state.inputFocused || this.state.menuFocused,\n                'has-autocomplete': true,\n            }),\n            autocomplete: this.props.autocomplete || false,\n            value,\n            onChange: this.handleChange,\n            onFocus: this.handleInputFocus,\n            onBlur: this.handleInputBlur,\n            onKeyDown: this.handleKeyDown,\n        };\n\n        return (\n            <div\n                className={ this.cn('autocomplete-case', { width: this.props.width }) }\n                data-test-id={ this.props['data-test-id'] }\n            >\n                <Input { ...props } />\n                { this.renderPopup() }\n            </div>\n        );\n    }\n\n    private renderPopup() {\n        const formattedOptionsList = this.props.options\n            ? this.formatOptionsList(this.props.options)\n            : [];\n\n        const opened = this.props.opened === undefined\n            ? (this.state.inputFocused || this.state.menuFocused)\n            : this.props.opened;\n\n        if (this.props.options.length === 0) {\n            this.popup = null;\n\n            return null;\n        }\n\n        if (this.props.renderPopupOnFocus && !opened) {\n            return null;\n        }\n\n        return [\n            <ResizeSensor onResize={ this.updatePopupStyles } key=\"popup-sensor\" />,\n            <Popup\n                className={ this.cn('popup', { custom: this.props.popupClassName }) }\n                size={ this.props.size }\n                ref={ (popup) => {\n                    this.popup = popup;\n                } }\n                for={ this.props.name }\n                visible={ opened }\n                onClickOutside={ this.handleClickOutside }\n                target=\"anchor\"\n                directions={ this.props.directions }\n                height={ this.props.popupMaxHeight ? 'default' : 'adaptive' }\n                padded={ false }\n                minWidth={ this.state.popupStyles.minWidth }\n                maxWidth={ this.state.popupStyles.maxWidth }\n                key=\"popup\"\n                maxHeight={ this.props.popupMaxHeight }\n            >\n                <Menu\n                    ref={ (menu) => {\n                        this.menu = menu;\n                    } }\n                    className={ this.cn('menu') }\n                    size={ this.props.size }\n                    mode=\"radio-check\"\n                    content={ formattedOptionsList }\n                    checkedItems={ [] }\n                    onItemCheck={ this.handleItemCheck }\n                    autoFocusFirstItem={ true }\n                    highlightedItem={ this.state.highlightedItem }\n                    onHighlightItem={ this.handleHighlightedItem }\n                    onFocus={ this.handleMenuFocus }\n                    onBlur={ this.handleMenuBlur }\n                    onKeyDown={ this.handleMenuKeyDown }\n                />\n            </Popup>,\n        ];\n    }\n\n    private handleItemCheck = (checkedItemsValues, event) => {\n        const checkedItemValue = checkedItemsValues.length ? checkedItemsValues[0] : this.state.checkedItemValue;\n        const checkedItem = this.getCheckedOption(this.props.options, checkedItemValue);\n\n        const newValue = checkedItem\n            ? (checkedItem.text || checkedItem.value)\n            : this.state.value;\n\n        if (this.props.onItemSelect) {\n            this.props.onItemSelect(checkedItem);\n        }\n\n        if (this.props.updateValueOnItemSelect) {\n            this.setState({ value: newValue });\n\n            if (this.props.onChange) {\n                this.props.onChange(newValue, event);\n            }\n        }\n\n        if (this.inputFocusTimeout) {\n            clearTimeout(this.inputFocusTimeout);\n        }\n\n        if (this.inputBlurTimeout) {\n            clearTimeout(this.inputBlurTimeout);\n        }\n\n        if (this.props.closeOnSelect) {\n            this.inputBlurTimeout = setTimeout(() => this.input.blur(), 0);\n        } else {\n            this.inputFocusTimeout = setTimeout(() => {\n                this.input.focus();\n                this.input.setSelectionRange(newValue.length);\n            }, 0);\n        }\n    };\n\n    private handleChange = (value, event) => {\n        this.setState({ value });\n\n        if (this.props.onChange) {\n            this.props.onChange(value, event);\n        }\n    };\n\n    private handleInputFocus = (event) => {\n        if (this.blurTimeout) {\n            clearTimeout(this.blurTimeout);\n            this.blurTimeout = null;\n        }\n\n        this.solveFocused(event);\n\n        this.setState({\n            highlightedItem: null,\n        });\n    };\n\n    private handleInputBlur = (event) => {\n        if (this.blurTimeout) {\n            clearTimeout(this.blurTimeout);\n        }\n\n        event.persist();\n\n        this.blurTimeout = setTimeout(() => {\n            this.solveFocused(event);\n            this.blurTimeout = null;\n        }, 0);\n    };\n\n    private handleMenuFocus = (event) => {\n        if (this.blurTimeout) {\n            clearTimeout(this.blurTimeout);\n            this.blurTimeout = null;\n        }\n\n        this.solveFocused(event);\n    };\n\n    private handleMenuBlur = (event) => {\n        if (this.blurTimeout) {\n            clearTimeout(this.blurTimeout);\n        }\n\n        event.persist();\n\n        this.blurTimeout = setTimeout(() => {\n            this.solveFocused(event);\n            this.blurTimeout = null;\n        }, 0);\n    };\n\n    private handleClickOutside = () => {\n        if (this.props.onClickOutside) {\n            this.props.onClickOutside();\n        }\n    };\n\n    private handleKeyDown = (event) => {\n        switch (event.which) {\n        case keyboardCode.DOWN_ARROW: {\n            event.preventDefault();\n\n            const posX = window.pageXOffset;\n            const posY = window.pageYOffset;\n\n            if (this.menu) {\n                this.menu.focus();\n            }\n\n            window.scrollTo(posX, posY);\n\n            break;\n        }\n\n        case keyboardCode.ESCAPE: {\n            this.input.blur();\n            break;\n        }\n        }\n\n        if (this.props.onKeyDown) {\n            this.props.onKeyDown(event);\n        }\n    };\n\n    private handleHighlightedItem = (highlightedItem) => {\n        this.setState({\n            highlightedItem,\n        });\n    };\n\n    private handleMenuKeyDown = (event, highlightedItem) => {\n        switch (event.which) {\n        case keyboardCode.DOWN_ARROW:\n        case keyboardCode.UP_ARROW:\n            event.preventDefault();\n            this.syncKeyboardNavigationWithScroll(highlightedItem);\n            break;\n\n        case keyboardCode.ESCAPE:\n            this.input.focus();\n            break;\n        }\n\n        if (this.props.onKeyDown) {\n            this.props.onKeyDown(event);\n        }\n    };\n\n    /**\n     * Устанавливает фокус на поле ввода.\n     */\n    public focus() {\n        this.input.focus();\n    }\n\n    /**\n     * Убирает фокус с поля ввода.\n     */\n    public blur() {\n        this.input.blur();\n    }\n\n    /**\n     * Скроллит страницу до поля ввода.\n     */\n    public scrollTo() {\n        this.input.scrollTo();\n    }\n\n    /**\n     * Определяет является ли весь компонент в фокусе на событиях onFocus/onBlur.\n     *\n     * @param event Событие focus/blur, которое будет проброшено в обработчик onFocus/onBlur\n     */\n    private solveFocused(event: React.SyntheticEvent) {\n        const currentFocused = this.state.inputFocused || this.state.menuFocused;\n\n        const focusedElement = document.activeElement;\n\n        const newState = {\n            inputFocused: (focusedElement === this.input.getControl()),\n            menuFocused: this.menu\n                ? (this.menu.getNode() === focusedElement || this.menu.getNode().contains(focusedElement))\n                : false,\n        };\n\n        const newFocused = newState.inputFocused || newState.menuFocused;\n\n        if (currentFocused !== newFocused) {\n            if (newFocused) {\n                if (this.props.onFocus) {\n                    this.props.onFocus(event);\n                }\n            } else if (this.props.onBlur) {\n                this.props.onBlur(event);\n            }\n        }\n\n        this.setState(newState);\n    }\n\n    private formatOptionsList(options) {\n        return (\n            options.map((option) => {\n                if (option.type === 'group' && !!option.content) {\n                    const content = this.formatOptionsList(option.content);\n\n                    return ({\n                        type: 'group',\n                        title: option.title,\n                        content,\n                    });\n                }\n\n                return ({\n                    key: option.key || option.value,\n                    value: option.value,\n                    content: option.description || option.value,\n                    props: option.props,\n                });\n            })\n        );\n    }\n\n    private getCheckedOption(options, value) {\n        let result = null;\n\n        options.find((option) => {\n            if (option.type === 'group' && !!option.content) {\n                const findInGroup = this.getCheckedOption(option.content, value);\n\n                if (findInGroup) {\n                    result = findInGroup;\n\n                    return true;\n                }\n            } else if (option.value === value) {\n                result = option;\n\n                return true;\n            }\n\n            return false;\n        });\n\n        return result;\n    }\n\n    private updatePopupStyles = () => {\n        const input = this.input.getNode();\n        const inputWidth = input.getBoundingClientRect().width;\n        const popupStyles = { minWidth: inputWidth };\n\n        if (this.props.equalPopupWidth) {\n            popupStyles.maxWidth = inputWidth;\n        }\n\n        this.setState({\n            popupStyles,\n        });\n    };\n\n    private updatePopupTarget() {\n        if (this.popup) {\n            this.popup.setTarget(this.input.getBoxNode());\n        }\n    }\n\n    /**\n     * @param highlightedItem Выбранный пункт меню\n     */\n    private syncKeyboardNavigationWithScroll(highlightedItem: MenuItem) {\n        const element = highlightedItem.getNode();\n        const container = this.popup.getInnerNode();\n        const correction = element.offsetHeight;\n\n        if (element.offsetTop + correction > container.scrollTop + container.offsetHeight) {\n            scrollTo({\n                container,\n                targetY: element.offsetTop,\n                duration: SCROLL_TO_NORMAL_DURATION,\n            });\n        } else if (element.offsetTop < container.scrollTop) {\n            scrollTo({\n                container,\n                targetY: (element.offsetTop - container.offsetHeight) + correction,\n                duration: SCROLL_TO_NORMAL_DURATION,\n            });\n        }\n    }\n}\n\nexport default withTheme<InputAutocompleteProps, InputAutocomplete>(InputAutocomplete);\n"]}