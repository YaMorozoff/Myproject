{"version":3,"sources":["lib/date-utils.ts"],"names":[],"mappings":"AAUA;;;;GAIG;AACH,wBAAgB,aAAa,CAAC,IAAI,EAAE,IAAI,GAAG,MAAM,GAAG,IAAI,CAEvD;AAED;;;;GAIG;AACH,wBAAgB,iBAAiB,CAAC,IAAI,EAAE,IAAI,GAAG,MAAM,CAOpD;AAkHD;;;;;;;;;;;;;;GAcG;AACH,wBAAgB,KAAK,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,SAAe,EAAE,MAAM,UAAO,GAAG,IAAI,CA4C/E","file":"date-utils.d.ts","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/* eslint no-continue: 0 */\n\nimport getDaysInMonth from 'date-fns/get_days_in_month';\n\nconst DAYS_IN_WEEK = 7;\n\n/**\n * Нормализирует дату, возвращает Date вне завистимости от входных данных.\n *\n * @param date Дата для нормализации.\n */\nexport function normalizeDate(date: Date | number): Date {\n    return new Date(date);\n}\n\n/**\n * Возвращает «правильный» индекс дня недели, 0 - пн, 1 - вт и так далее.\n *\n * @param date Дата, из которой нужно получить день недели.\n */\nexport function getRussianWeekDay(date: Date): number {\n    const sunday = 0;\n    const foreignWeekDayIndex = date.getDay();\n\n    return foreignWeekDayIndex === sunday\n        ? DAYS_IN_WEEK - 1\n        : foreignWeekDayIndex - 1;\n}\n\nconst PARSE_TOKENS: DateParserToken[] = [\n    { type: 'date', regex: /^\\d{2}/, formatRegex: /^DD/ },\n    { type: 'date', regex: /^\\d{1,2}/, formatRegex: /^D/ },\n    { type: 'month', regex: /^\\d{2}/, formatRegex: /^MM/ },\n    { type: 'month', regex: /^\\d{1,2}/, formatRegex: /^M/ },\n    { type: 'year', regex: /^\\d{4}/, formatRegex: /^YYYY/ },\n];\n\ntype Limit = {\n    /**\n     * Минимально возможное значение\n     */\n    min: number;\n    /**\n     * Максимально возможное значение\n     */\n    max: number;\n}\n\ntype DateLimits = {\n    /**\n     * Лимиты для дня\n     */\n    date: Limit;\n    /**\n     * Лимиты для месяца\n     */\n    month: Limit;\n    /**\n     * Лимиты для года\n     */\n    year: Limit;\n}\n\n/**\n * Возвращает граничные значения для дня, месяца, года.\n *\n * @param month Месяц в котором нужно получить максимально возможное число дней.\n * @param year Год месяца в котором нужно получить максимально возможное число дней.\n * @returns Лимиты для переданной даты\n */\nfunction getLimits(month: number, year: number): DateLimits {\n    return {\n        date: { min: 1, max: getDaysInMonth(new Date(year, month - 1)) },\n        month: { min: 1, max: 12 },\n        year: { min: 1, max: Number.MAX_SAFE_INTEGER },\n    };\n}\n\ntype DateType = 'date' | 'month' | 'year';\n\ntype FormatParserToken = DateParserToken | DelimiterParserToken;\n\ntype DelimiterParserToken = {\n    /**\n     * Тип токена\n     */\n    type: 'delimiter';\n    /**\n     * Символ разделитель\n     */\n    value: string;\n}\n\ntype DateParserToken = {\n    /**\n     * Тип токена\n     */\n    type: DateType;\n    /**\n     * Регулярное выражение, соответствующее формату\n     */\n    formatRegex: RegExp;\n    /**\n     * Регулярное выражение для проверки соответствия формату\n     */\n    regex: RegExp;\n}\n\nconst PARSER_CACHE = {};\n\n/**\n * Разбирает строку с форматом даты.\n *\n * @param format формат даты для разбора.\n */\nfunction parseFormat(format: string): FormatParserToken[] {\n    if (PARSER_CACHE[format]) {\n        return PARSER_CACHE[format];\n    }\n\n    const parser: FormatParserToken[] = [];\n    let processingFormat = format;\n\n    while (processingFormat.length > 0) {\n        /* eslint no-loop-func: 0 */\n        const matchedToken = PARSE_TOKENS.find((t) => processingFormat.match(t.formatRegex));\n\n        if (matchedToken) {\n            parser.push(matchedToken);\n            processingFormat = processingFormat.replace(matchedToken.formatRegex, '');\n        } else {\n            parser.push({ type: 'delimiter', value: processingFormat[0] });\n            processingFormat = processingFormat.substring(1);\n        }\n    }\n\n    PARSER_CACHE[format] = parser;\n\n    return parser;\n}\n\n/**\n * Разбирает дату из строки по заданному формату.\n * Допустимые элементы формата:\n * D - дата, в формате 1-31\n * DD - дата, в формате 01-31,\n * M - месяц, в формате 1-12,\n * MM - месяц, в формате 01-12\n * YYYY - год\n * В качестве разделителей между элементами даты могут выступать любые символы, не являющиеся частью формата.\n *\n * @param input Входная строка для разбора.\n * @param format Формат, который будет использоваться для разбора.\n * @param strict Запрещать ли значения, выходящие за пределы логических ограничений месяцев/дней.\n * В случае если strict=false 22 месяц будет интерпретироваться как год и 10 месяцев.\n */\nexport function parse(input: string, format = 'DD.MM.YYYY', strict = true): Date {\n    const parsedFormat = parseFormat(format);\n    const parsedResult: Partial<Record<DateType, number>> = {};\n\n    for (let i = 0; i < parsedFormat.length; i++) {\n        const token = parsedFormat[i];\n\n        if (token.type === 'delimiter') {\n            if (input[0] !== token.value) {\n                return new Date('invalid');\n            }\n            // eslint-disable-next-line no-param-reassign\n            input = input.substring(1);\n            continue;\n        }\n\n        const match = input.match(token.regex);\n\n        if (!match) {\n            return new Date('invalid');\n        }\n\n        parsedResult[token.type] = parseInt(match[0], 10);\n        // eslint-disable-next-line no-param-reassign\n        input = input.replace(token.regex, '');\n    }\n\n    const {\n        date: dateLimits,\n        month: monthLimits,\n        year: yearLimits,\n    } = getLimits(parsedResult.month, parsedResult.year);\n\n    if (\n        strict && (\n            parsedResult.date > dateLimits.max || parsedResult.date < dateLimits.min\n            || parsedResult.month > monthLimits.max || parsedResult.month < monthLimits.min\n            || parsedResult.year > yearLimits.max || parsedResult.year < yearLimits.min\n        )\n    ) {\n        return new Date('invalid');\n    }\n\n    return new Date(parsedResult.year, parsedResult.month - 1, parsedResult.date || 1);\n}\n"]}