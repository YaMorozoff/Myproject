{"version":3,"sources":["lib/prop-types.ts"],"names":[],"mappings":"AAgEA;;;;;GAKG;AACH,wBAAgB,UAAU,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,GAAG,QAAQ,CAiBxE;AAED;;;;;;;;GAQG;AACH,wBAAgB,cAAc,CAAC,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,GAAG,QAAQ,CAgB9F;AAED;;GAEG;AACH,eAAO,MAAM,WAAW,UAAoD,CAAC;AAE7E;;;;;GAKG;AACH,wBAAgB,0BAA0B,CAAC,iBAAiB,KAAA,EAAE,mBAAmB,KAAA;;qDAqBhF","file":"prop-types.d.ts","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * Функции объявленные в этом файле используются в сторонних либах для валидации propTypes в рантайме,\n * т.к. компоненты библиотеки могут использоваться в js, где нет проверок типов Typescript\n */\n\n/**\n * Добавляет к type-checker для propType валидации метод isRequired\n *\n * @param validate оригинальный метод для валидации\n */\nfunction createChainableTypeChecker(\n    validate: (props: { [key: string]: any }, propName: string, componentName: string, location: string) => void,\n) {\n    function checkType(\n        isRequired: boolean,\n        props: { [key: string]: any },\n        propName: string,\n        componentName: string,\n        location: string,\n    ) {\n        // eslint-disable-next-line no-param-reassign\n        componentName = componentName || '';\n        if (props[propName] === null || props[propName] === undefined) {\n            if (isRequired) {\n                return new Error(\n                    `Required prop \\`${propName}\\` was not specified in \\`${componentName}\\`.`,\n                );\n            }\n\n            return null;\n        }\n\n        return validate(props, propName, componentName, location);\n    }\n\n    const chainedCheckType = checkType.bind(null, false);\n\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType as Function;\n}\n\n/**\n * Проверяет, является ли заданный prop инстансом HTMLElement\n *\n * @param props пропы компонента\n * @param propName имя пропса для валидации\n * @param componentName имя компонента\n */\nfunction propTypeIsHtmlElement(props: { [key: string]: any }, propName: string, componentName: string): Error | null {\n    if (!(props[propName] instanceof (typeof HTMLElement === 'undefined' ? {} as any : HTMLElement))) {\n        return new Error(\n            `Invalid prop \\`${propName}\\` supplied to \\`${componentName}\\`.\n            Expected valid HTMLElement object, ${typeof props[propName]} given.`,\n        );\n    }\n\n    return null;\n}\n\n/**\n * Враппер для prop-type валидаторов, позволяющий помечать prop как устаревший, сохраняя проверку типа\n *\n * @param propType оригинальный propType валидатор\n * @param message дополнительное сообщение\n */\nexport function deprecated(propType: Function, message: string): Function {\n    let warned = false;\n\n    return function (...args) {\n        const [props, propName, componentName] = args;\n        const prop = props[propName];\n\n        if (prop !== undefined && prop !== null && !warned) {\n            warned = true;\n            if (process.env.NODE_ENV !== 'production') {\n                // eslint-disable-next-line no-console\n                console.warn(`Property '${propName}' of '${componentName}' is deprecated. ${message}`);\n            }\n        }\n\n        return propType.call(this, ...args);\n    };\n}\n\n/**\n * Враппер для prop-type валидатора, позволяющий пометить один из типов как устаревший.\n * В случае, если заданный prop будет соответствовать старому валидатору, но не будет\n * соответствовать новому - пользователь будет об этом предупрежден\n *\n * @param oldType валидатор для старого типа.\n * @param newType валидатор для нового типа.\n * @param message дополнительное сообщение\n */\nexport function deprecatedType(oldType: Function, newType: Function, message: string): Function {\n    let warned = false;\n\n    return function (...args) {\n        const [, propName, componentName] = args;\n        const oldResult = oldType.call(this, ...args);\n        const newResult = newType.call(this, ...args);\n\n        if (process.env.NODE_ENV !== 'production' && !oldResult && !warned && newResult) {\n            warned = true;\n            // eslint-disable-next-line no-console\n            console.warn(`Given type of '${propName}' of '${componentName}' is deprecated. ${message}`);\n        }\n\n        return newResult;\n    };\n}\n\n/**\n * Готовый prop-type валидатор для проверки, что значение переданное в проп является HtmlElement\n */\nexport const HtmlElement = createChainableTypeChecker(propTypeIsHtmlElement);\n\n/**\n * Проверяет что значение пропса из заданного множества\n *\n * @param validationMapping множество допустимых значений пропса\n * @param controllingPropName имя контролируемого пропса\n */\nexport function createMappingPropValidator(validationMapping, controllingPropName) {\n    return function validateProp(props: { [key: string]: any }, propName: string, componentName: string) {\n        const controllingPropValue = props[controllingPropName];\n        const controlledPropValue = props[propName];\n\n        const propsDefined = controllingPropValue && controlledPropValue;\n        const availableOptions = validationMapping[controllingPropValue];\n\n        if (!propsDefined || !Array.isArray(availableOptions)) {\n            return null;\n        }\n\n        const isValidProp = availableOptions.indexOf(props[propName]) !== -1;\n\n        if (!isValidProp) {\n            return new Error(`Invalid prop '${propName}' supplied to ${componentName}.\n                Expected one of ${availableOptions} for prop '${controllingPropName}' equal to ${controllingPropValue}`);\n        }\n\n        return null;\n    };\n}\n"]}